# PYTHON
![python logo](./src/img/Python-Logo.png)

¬°Hola a todos los futuros programadores y programadoras! En este emocionante viaje hacia el mundo de la programaci√≥n, hoy vamos a explorar un lenguaje de programaci√≥n s√∫per vers√°til y poderoso llamado Python. Pero antes de sumergirnos en la magia de la codificaci√≥n, necesitamos entender que es python y preparar nuestro entorno de desarrollo.



## ¬øQu√© es Python?<a name="python"></a>

Python es un lenguaje de programaci√≥n que se ha vuelto extremadamente popular en todo el mundo. ¬øSab√≠as que es el lenguaje detr√°s de aplicaciones web como Instagram y YouTube? ¬°Incre√≠ble, verdad?

Python es un lenguaje de programaci√≥n de alto nivel, interpretado y generalmente f√°cil de aprender. Fue creado por Guido van Rossum y lanzado por primera vez en 1991. Desde entonces, ha evolucionado y madurado hasta convertirse en uno de los lenguajes de programaci√≥n m√°s populares y utilizados en todo el mundo.

¬øSab√≠as que Python comenz√≥ como un proyecto de hobby? Su creador, Guido van Rossum, era un apasionado de la programaci√≥n y quer√≠a crear un lenguaje que fuera f√°cil de entender y poderoso. En diciembre de 1989, mientras buscaba un proyecto para mantenerse ocupado, decidi√≥ crear un int√©rprete para un nuevo lenguaje de scripting que hab√≠a estado ideando. ¬øSabes qu√© le inspir√≥ para nombrarlo "Python"? ¬°Su amor por el grupo de comedia Monty Python! As√≠ que, aunque parezca extra√±o, este lenguaje debe su nombre a un grupo de comediantes brit√°nicos.

### La Versatilidad de Python

Una de las razones por las que Python se ha vuelto tan popular es su versatilidad. Puedes usar Python para muchas cosas diferentes. Aqu√≠ hay algunos ejemplos:

- **Desarrollo Web**: Python se utiliza para crear sitios web. Maneja tareas como el env√≠o y procesamiento de datos, la comunicaci√≥n con bases de datos y la seguridad.

- **Desarrollo de Software**: En el desarrollo de software, Python puede ayudar en el control de construcci√≥n, seguimiento de errores y automatizaci√≥n de pruebas.

- **Ciencia de Datos**: Python es una herramienta esencial en el an√°lisis de datos. Puede manejar grandes conjuntos de datos y realizar an√°lisis complejos.

- **Automatizaci√≥n de Procesos**: Python puede automatizar tareas repetitivas, lo que lo hace √∫til en la industria para ahorrar tiempo y recursos.

- **Inteligencia Artificial y Aprendizaje Autom√°tico**: Gracias a su ecosistema de bibliotecas, Python es perfecto para proyectos de inteligencia artificial y aprendizaje autom√°tico.

- **Desarrollo de Juegos**: Incluso se usa en la creaci√≥n de videojuegos populares como Los Sims 4 y Battlefield 2.

![aplicaciones](./src/img/campos-de-aplicacion.jpg)

### Razones para Aprender Python

Ahora, te preguntar√°s por qu√© deber√≠as aprender Python. Bueno, aqu√≠ tienes algunas razones:

- **F√°cil de Leer**: Python se enorgullece de tener una sintaxis f√°cil de entender, lo que lo hace perfecto para principiantes.

- **C√≥digo Abierto y Gratuito**: ¬°Puedes usar Python de forma gratuita! Incluso para proyectos comerciales.

- **Gran Comunidad**: Si te encuentras con un problema, es probable que alguien m√°s ya lo haya resuelto. La comunidad de Python es enorme y solidaria.

- **Portabilidad**: Puedes escribir c√≥digo Python en una plataforma y ejecutarlo en otra sin problemas.

![razones](./src/img/razones-python.png)

Python es un lenguaje de programaci√≥n fascinante que se ha convertido en una herramienta esencial en el mundo de la tecnolog√≠a. Grandes empresas como NASA, Google, Netflix y Spotify conf√≠an en Python para impulsar sus servicios y productos.

As√≠ que, si est√°s pensando en aprender programaci√≥n, Python es un excelente lugar para empezar. ¬°Es una habilidad con un gran futuro y una demanda creciente en la industria!

## Configuraci√≥n del Entorno de Desarrollo<a name="install-py"></a>

Ahora, hablemos sobre la configuraci√≥n de tu "entorno de desarrollo". Esto suena un poco complicado, ¬°pero no te preocupes! B√°sicamente, es el lugar donde escribir√°s, probar√°s y ejecutar√°s tu c√≥digo Python. 

Configurar un entorno de desarrollo de Python es el primer paso esencial para cualquier programador que quiera comenzar a trabajar con este vers√°til lenguaje de programaci√≥n. Ya sea que est√©s planeando desarrollar aplicaciones web, explorar la inteligencia artificial o simplemente aprender a programar, la configuraci√≥n adecuada del entorno te ayudar√° a empezar de manera efectiva. En este apartado, te guiar√© a trav√©s de los pasos iniciales para configurar tu entorno de desarrollo de Python.



### 1. Instala Python

Imagina que Python es como una pluma antes de comenzar a escribir en el mundo de la programaci√≥n. Es una herramienta fundamental que necesitas tener en tu caja de herramientas inform√°ticas. Afortunadamente, instalar Python en tu computadora es un proceso sencillo y esencial para cualquier aspirante a programador.

#### **Paso 1: Descarga Python**

El primer paso es obtener el software Python en tu computadora. Para hacerlo, simplemente visita el sitio web oficial de Python en [python.org](https://www.python.org/downloads/). All√≠ encontrar√°s la √∫ltima versi√≥n disponible para descargar.

![Descargar python](./src/img/py-download.png)

#### **Paso 2: Instalaci√≥n en Sistemas Unix (Linux o macOS)**

Si est√°s utilizando un sistema operativo basado en Unix, como Linux o macOS, es posible que ya tengas una versi√≥n de Python preinstalada. Sin embargo, te recomendamos encarecidamente que utilices la √∫ltima versi√≥n disponible desde el sitio web oficial.

Una vez que hayas descargado el archivo de instalaci√≥n, ejec√∫talo siguiendo las instrucciones. Esto asegurar√° que est√°s utilizando la versi√≥n m√°s actualizada de Python.

#### **Paso 3: Instalaci√≥n en Windows**

Para los usuarios de Windows, tambi√©n puedes descargar Python desde el sitio web oficial. Durante la instalaci√≥n, aseg√∫rate de marcar la casilla que dice "Agregar Python X.X a PATH" (donde "X.X" es la versi√≥n de Python). Esto es importante porque permite que Python sea f√°cilmente accesible desde la l√≠nea de comandos de Windows.

![Alt text](./src/img/install-check.png)

Una vez que hayas completado estos pasos, habr√°s instalado Python en tu sistema. Ahora est√°s listo para aventurarte en el emocionante mundo de la programaci√≥n.

### 2. Elige un Editor de Texto<a name="editor"></a>


El siguiente paso es elegir un editor de c√≥digo o un IDE que te ayude a escribir y depurar c√≥digo de Python de manera eficiente. Algunas opciones populares incluyen:

- **Visual Studio Code (VSCode)**: Es un editor de c√≥digo gratuito y altamente personalizable que ofrece una excelente experiencia para programar en Python. Puedes instalar extensiones como "Python" y "Pylance" para mejorar a√∫n m√°s la funcionalidad.

- **PyCharm**: Es un IDE espec√≠ficamente dise√±ado para Python. La versi√≥n Community es gratuita y ofrece una gran cantidad de caracter√≠sticas √∫tiles para los desarrolladores de Python.

- **Jupyter Notebook**: Es una herramienta fant√°stica para la exploraci√≥n de datos y el desarrollo interactivo de Python. Viene preinstalado en Anaconda, una distribuci√≥n de Python que es popular en el √°mbito de la ciencia de datos.

![IDE vs Editor](./src/img/Editor_vs_IDE.png)

### Paso 3: Instalar Bibliotecas y Dependencias

La mayor√≠a de los proyectos de Python requerir√°n bibliotecas y dependencias adicionales. Puedes utilizar la herramienta `pip` para instalar paquetes de Python. Por ejemplo, para instalar la popular biblioteca NumPy, simplemente ejecuta:

```bash
pip install numpy
```

Recuerda que si est√°s utilizando un entorno virtual, debes activarlo antes de usar `pip` para asegurarte de que las bibliotecas se instalen en el entorno correcto.

![bibliotecas](./src/img/librrerias-python.jpg)

## Paso 5: ¬°Comienza a Programar!<a name="primer-programa"></a>

¬°Ahora que has configurado tu entorno de desarrollo de Python, est√°s listo para empezar a programar! Puedes escribir c√≥digo Python en tu editor de elecci√≥n, ejecutarlo y ver los resultados. Python es un lenguaje vers√°til con una amplia comunidad y recursos en l√≠nea, por lo que siempre encontrar√°s ayuda y documentaci√≥n disponibles cuando la necesites.

#### 3. ¬°Hola, Mundo!

Ahora que todo est√° configurado, es hora de hacer tu primer programa Python. Abre tu editor de texto y escribe lo siguiente:

```python
print("¬°Hola, Mundo!")
```

Luego, guarda el archivo con una extensi√≥n ".py", por ejemplo, "mi_primer_programa.py". Esto le dice a tu computadora que es un programa de Python.

#### 4. Ejecuta tu Programa

Abre tu l√≠nea de comandos (si usas Windows, es el "S√≠mbolo del sistema" o "CMD"; en Mac o Linux, es la "Terminal"). Navega a la ubicaci√≥n donde guardaste tu archivo ".py" y escribe:

```zsh
python mi_primer_programa.py
```

¬°Y listo! Ver√°s la frase "¬°Hola, Mundo!" en la pantalla. ¬°Has escrito y ejecutado tu primer programa Python!


### Sem√°ntica y Sintaxis en Python

Python, uno de los lenguajes de programaci√≥n m√°s populares del mundo, es conocido por su simplicidad y legibilidad. Pero para dominarlo, es fundamental entender dos conceptos clave: **sintaxis** y **sem√°ntica**. Mientras que la sintaxis en Python se refiere a las reglas que definen c√≥mo se deben estructurar las instrucciones del c√≥digo, la sem√°ntica se ocupa del significado de esas instrucciones. En este blog, exploraremos ambos conceptos, destacando su importancia y c√≥mo afectan a tu c√≥digo en Python.

#### ¬øQu√© es la Sintaxis en Python?

La sintaxis de Python es como la gram√°tica de un idioma. Define las reglas sobre c√≥mo deben estructurarse las instrucciones de c√≥digo para que Python pueda entenderlas y ejecutarlas. A diferencia de otros lenguajes de programaci√≥n que pueden tener una sintaxis m√°s compleja, Python se destaca por su simplicidad y legibilidad, lo que lo hace ideal tanto para principiantes como para expertos.

**Ejemplo de Sintaxis:**

```python
# Un sencillo ejemplo de sintaxis en Python
nombre = "Alice"
print("Hola, " + nombre + "!")
```

En este c√≥digo:

- La l√≠nea `nombre = "Alice"` asigna la cadena "Alice" a la variable `nombre`.
- La l√≠nea `print("Hola, " + nombre + "!")` imprime un saludo combinando texto est√°tico y el valor de la variable.

En Python, es crucial respetar la indentaci√≥n, ya que define bloques de c√≥digo. Por ejemplo, en estructuras de control como `if`, `for`, y `while`, el c√≥digo dentro del bloque debe estar correctamente indentado.

**Ejemplo de Indentaci√≥n:**

```python
edad = 20

if edad >= 18:
    print("Eres mayor de edad.")
else:
    print("Eres menor de edad.")
```

Si no respetas la indentaci√≥n, Python lanzar√° un error de sintaxis. Esto enfatiza la importancia de escribir c√≥digo limpio y bien estructurado.

#### ¬øQu√© es la Sem√°ntica en Python?

La sem√°ntica en Python se refiere al significado de las instrucciones de c√≥digo que escribes. Mientras que la sintaxis asegura que el c√≥digo est√© estructurado correctamente, la sem√°ntica asegura que el c√≥digo haga lo que esperas que haga.

**Ejemplo de Sem√°ntica:**

```python
x = 10
y = "5"
z = x + y  # Esto lanzar√° un TypeError
```

En este ejemplo, aunque la sintaxis es correcta (no hay errores de sintaxis), el c√≥digo tiene un problema sem√°ntico. No puedes sumar un entero (`x = 10`) con una cadena (`y = "5"`). Esto resultar√° en un error de tipo (`TypeError`). La sem√°ntica asegura que los tipos de datos sean compatibles entre s√≠ y que las operaciones realizadas tengan sentido.

Otro aspecto importante de la sem√°ntica es el flujo l√≥gico del programa. Considera el siguiente ejemplo:

```python
edad = 20

if edad >= 18:
    print("Eres menor de edad.")
else:
    print("Eres mayor de edad.")
```

Aunque este c√≥digo tiene una sintaxis correcta, sem√°nticamente es incorrecto, ya que la condici√≥n del `if` est√° invertida. Este tipo de errores pueden ser dif√≠ciles de detectar porque el c√≥digo se ejecuta sin errores de sintaxis, pero el resultado no es el deseado.

#### Importancia de Comprender la Sintaxis y Sem√°ntica

Entender la diferencia entre sintaxis y sem√°ntica es crucial para cualquier programador de Python. La sintaxis es el primer paso: si no escribes el c√≥digo correctamente, Python no podr√° ejecutarlo. Pero incluso con la sintaxis correcta, debes asegurarte de que tu c√≥digo tenga sentido l√≥gico y haga lo que pretendes.

Errores sem√°nticos pueden llevar a resultados inesperados o, en el peor de los casos, a fallos en tu programa. Por eso, adem√°s de aprender las reglas sint√°cticas, es vital desarrollar una comprensi√≥n profunda de c√≥mo Python maneja los diferentes tipos de datos, estructuras de control, y c√≥mo interact√∫an entre s√≠.



La combinaci√≥n de una sintaxis clara y una sem√°ntica l√≥gica es lo que hace que Python sea un lenguaje tan poderoso y flexible. Al dominar ambos aspectos, estar√°s en el camino correcto para escribir c√≥digo eficiente y libre de errores. Recuerda que la pr√°ctica constante y el an√°lisis cr√≠tico de tu c√≥digo son claves para mejorar tanto en la sintaxis como en la sem√°ntica.

¬°Ahora que entiendes mejor estos conceptos, est√°s listo para escribir c√≥digo en Python con mayor confianza y precisi√≥n!


Ahora tienes Python en tu computadora y est√°s listo para comenzar tu emocionante viaje en el mundo de la programaci√≥n. No te preocupes si al principio todo parece un poco confuso, ¬°todos empezamos desde alg√∫n lugar!

### ***Dale clic a üëâüèª [Playground](./Practics/01_Hello-world.md) üëàüèª***

# Variables<a name="variables"></a>

Ahora vamos a adentrarnos en el emocionante mundo de Python y explorar un concepto fundamental: las variables. No te preocupes si esto suena un poco t√©cnico, ¬°lo explicaremos de manera sencilla y divertida!

### ¬øQu√© son las Variables en Python?

Imagina que una variable es como una caja m√°gica donde puedes guardar cosas. Cada vez que pones algo en la caja, le das un nombre para recordar lo que contiene. En Python, una variable es como esa caja m√°gica. Es un lugar donde puedes guardar datos y darles un nombre. ¬øPor qu√© son importantes? Porque permiten que tu programa recuerde informaci√≥n y realice tareas inteligentes.

![variables](./src/img/variables.png)

Por ejemplo, si quieres guardar tu edad en Python, puedes hacerlo as√≠:

```python
edad = 12
```
### Nombres de Variables en Python

Puedes darles cualquier nombre a tus variables, pero hay algunas reglas que debes seguir:

- El nombre de la variable no puede comenzar con un n√∫mero.
- Debe comenzar con una letra o un gui√≥n bajo.
- Puedes usar letras, n√∫meros y guiones bajos en el nombre de la variable.
- Python distingue entre may√∫sculas y min√∫sculas. "edad" y "Edad" ser√≠an dos variables diferentes.


#### Crear una Variable

En Python, crear una variable es s√∫per f√°cil. Solo tienes que pensar en un nombre para tu variable y decirle a Python qu√© hay dentro. Por ejemplo:

```python
edad = 12
nombre = "Luis"
```

Aqu√≠, hemos creado dos variables. "edad" guarda el n√∫mero 12 y "nombre" guarda la palabra "Luis".

#### 2. Usar una Variable

Una vez que tienes una variable, puedes usarla en tu programa. Por ejemplo, podemos imprimir el valor de "edad" y "nombre" en la pantalla:

```python
print("Mi nombre es", nombre)
print("Tengo", edad, "a√±os")
```

Cuando ejecutes este c√≥digo, ver√°s que Python toma el valor de las variables y lo muestra en la pantalla.

¬°Las variables tambi√©n pueden usarse en operaciones matem√°ticas!



### Cambiando el Valor de una Variable

Las variables pueden cambiar de valor. Por ejemplo, si celebramos un cumplea√±os, podemos aumentar la edad en 1:

```python
edad = edad + 1
print("¬°Feliz cumplea√±os! Ahora tengo", edad, "a√±os")
```

¬°Ves c√≥mo la variable "edad" cambia su valor?

## Todo lo que Debes Saber sobre print en Python


La funci√≥n incorporada print puede parecer b√°sico al principio, pero ten en cuenta que ser√° una herramienta que usar√°s de m√∫ltiples maneras a lo largo de tu c√≥digo. Desde el ic√≥nico ‚ÄúHola mundo‚Äù hasta mensajes de depuraci√≥n y presentaci√≥n de resultados, print es la puerta de entrada a la comunicaci√≥n de tus programas con el mundo exterior.

Iniciar con un simple ‚ÄúHola mundo‚Äù no solo es una tradici√≥n en la programaci√≥n, sino tambi√©n un momento crucial donde tu c√≥digo cobra vida. Es la primera l√≠nea de c√≥digo que demuestra que tu entorno de desarrollo est√° configurado correctamente y que est√°s listo para empezar a crear.

Aprender√°s a aprovechar al m√°ximo la funci√≥n incorporada print en Python. Desde formatos avanzados hasta el manejo de caracteres especiales y secuencias de escape, descubrir√°s c√≥mo print puede ser una herramienta poderosa y vers√°til en tu caja de herramientas de programaci√≥n.

1. Uso b√°sico de print
El uso m√°s sencillo de print consiste en pasar el texto que deseas mostrar entre comillas. Este c√≥digo imprimir√° ‚ÄúNunca pares de aprender‚Äù en la consola, siendo una excelente forma de probar si tu entorno de Python est√° configurado correctamente.

```python
print("Nunca pares de aprender")
```
Resultado:

    Nunca pares de aprender

2. Uso de la coma en print
La coma dentro de la funci√≥n print se usa para separar varios argumentos. Al hacerlo, Python a√±ade autom√°ticamente un espacio entre los argumentos. Esto es diferente a concatenar cadenas con el operador +, que no a√±ade espacios adicionales.

```python
print("Nunca", "pares", "de", "aprender")
```
Resultado:

    Nunca pares de aprender

Por otro lado, al concatenar cadenas con el operador +, los elementos se unen sin ning√∫n espacio adicional, a menos que lo a√±adas expl√≠citamente.

```python
print("Nunca" + "pares" + "de" + "aprender")
```

Resultado:

    Nuncaparesdeaprender

Para a√±adir un espacio expl√≠citamente cuando concatenas cadenas, debes incluirlo dentro de las comillas.

```python
print("Nunca" + " " + "pares" + " " + "de" + " " + "aprender")
```

Resultado:

    Nunca pares de aprender

3. Uso de sep
El par√°metro sep permite especificar c√≥mo separar los elementos al imprimir. En este ejemplo, los elementos ‚ÄúNunca‚Äù, ‚Äúpares‚Äù, ‚Äúde‚Äù y ‚Äúaprender‚Äù se imprimir√°n con una coma y un espacio entre ellos, resultando en ‚ÄúNunca, pares, de, aprender‚Äù. Puedes cambiar sep por cualquier cadena de caracteres que desees usar como separador.

```python
print("Nunca", "pares", "de", "aprender", sep=", ")
```

Resultado:

    Nunca, pares, de, aprender

4. Uso de end
El par√°metro end cambia lo que se imprime al final de la llamada a print. En lugar de imprimir cada mensaje en una nueva l√≠nea, end="" asegura que ‚ÄúNunca‚Äù y ‚Äúpares‚Äù se impriman en la misma l√≠nea, resultando en ‚ÄúNunca pares‚Äù. Por defecto, end es un salto de l√≠nea ("\n"), lo que hace que cada llamada a print comience en una nueva l√≠nea.

```python
print("Nunca", end=" ")
print("pares de aprender")
```

Resultado:

    Nunca pares de aprender

5. Impresi√≥n de variables
Puedes usar print para mostrar el valor de las variables. En este ejemplo, imprimir√° ‚ÄúFrase: Nunca pares de aprender‚Äù y ‚ÄúAutor: Platzi‚Äù. Esto es √∫til para depurar y ver los valores de las variables en diferentes puntos de tu programa.

```python
frase = "Nunca pares de aprender"
author = "Platzi"
print("Frase:", frase, "Autor:", author)
```

Resultado:

    Frase: Nunca pares de aprender Autor: Platzi

6. Uso de formato con f-strings
Las f-strings permiten insertar expresiones dentro de cadenas de texto. Al anteponer una f a la cadena de texto, puedes incluir variables directamente dentro de las llaves {}. En este ejemplo, frase y author se insertar√°n en la cadena, resultando en ‚ÄúFrase: Nunca pares de aprender, Autor: Platzi‚Äù. Esto hace que el c√≥digo sea m√°s legible y f√°cil de escribir.

```python
frase = "Nunca pares de aprender"
author = "Platzi"
print(f"Frase: {frase}, Autor: {author}")
```

Resultado:

    Frase: Nunca pares de aprender, Autor: Platzi


7. Uso de formato con format
El m√©todo format es otra forma de insertar valores en cadenas de texto. Usando {} como marcadores de posici√≥n, puedes pasar los valores que quieres insertar como argumentos de format. En este ejemplo, se imprimir√° ‚ÄúFrase: Nunca pares de aprender, Autor: Platzi‚Äù. Es una forma flexible y poderosa de formatear cadenas, aunque las f-strings son m√°s concisas.

```python
frase = "Nunca pares de aprender"
author = "Platzi"
print("Frase: {}, Autor: {}".format(frase, author))
```

Resultado:

    Frase: Nunca pares de aprender, Autor: Platzi

8. Impresi√≥n con formato espec√≠fico
Puedes controlar el formato de los n√∫meros al imprimir. En este ejemplo, :.2f indica que el n√∫mero debe mostrarse con dos decimales. As√≠, imprimir√° ‚ÄúValor: 3.14‚Äù, redondeando el n√∫mero a dos decimales. Esto es especialmente √∫til cuando trabajas con datos num√©ricos y necesitas un formato espec√≠fico.

```python
valor = 3.14159
print("Valor: {:.2f}".format(valor))
```

Resultado:

    Valor: 3.14

9. Saltos de l√≠nea y caracteres especiales
Los saltos de l√≠nea en Python se indican con la secuencia de escape \n. Por ejemplo, para imprimir ‚ÄúHola\nmundo‚Äù, que aparecer√° en dos l√≠neas:

```python
print("Hola\nmundo")
```

Resultado:

    Hola
    mundo

Para imprimir una cadena que contenga comillas simples o dobles dentro de ellas, debes usar secuencias de escape para evitar confusiones con la sintaxis de Python. Por ejemplo, para imprimir la frase ‚ÄúHola soy ‚ÄòCarli‚Äô‚Äù:

```python
print('Hola soy \'Carli\'')
```

Resultado:

    Hola soy 'Carli'

Si necesitas imprimir una ruta de archivo en Windows, que incluya barras invertidas, tambi√©n necesitar√°s usar secuencias de escape para evitar que Python interprete las barras invertidas como parte de secuencias de escape. Por ejemplo:

```python
print("La ruta de archivo es: C:\\Users\\Usuario\\Desktop\\archivo.txt")
```

Resultado:

    La ruta de archivo es: C:\Users\Usuario\Desktop\archivo.txt
    
En Python, estas secuencias de escape te permiten manejar caracteres especiales y estructurar la salida de texto seg√∫n sea necesario, asegurando que la salida se formatee correctamente en la consola o en cualquier otro medio donde se imprima.

Con estos ejemplos y explicaciones adicionales, tendr√°s una comprensi√≥n m√°s completa sobre c√≥mo manejar saltos de l√≠nea y caracteres especiales en Python al usar la funci√≥n print.

# Tipos de datos<a name="tipos-datos"></a>

### Tipos de Datos en Variables

Imagina que tienes una caja m√°gica (s√≠, otra vez) y quieres guardar cosas en ella, pero esta vez quieres separarlas seg√∫n lo que sean: n√∫meros, palabras, etc. Los tipos de datos en Python son como etiquetas que te ayudan a organizar y trabajar con diferentes tipos de informaci√≥n.

Veamos algunos de los tipos de datos m√°s comunes en Python:

- **Enteros (int)**: Guardan n√∫meros enteros, como la edad en nuestro ejemplo.
- **Cadenas de Texto (str)**: Guardan palabras o frases, como el nombre.
- **Decimales (float)**: Guardan n√∫meros con decimales, como 3.14.
- **Booleanos (bool)**: Guardan valores verdaderos o falsos, como True o False.

#### 1. Enteros (int)

Los n√∫meros enteros son como tu edad, ¬°n√∫meros sin decimales! Por ejemplo:

```python
mi_edad = 12
```

En este caso, "mi_edad" es una variable de tipo entero que almacena el valor 12.

#### 2. Flotantes (float)

Los n√∫meros flotantes son n√∫meros con decimales. Por ejemplo:

```python
altura = 1.75
```

La variable "altura" es un flotante y contiene el valor 1.75.

#### 3. Cadenas de Texto (str)

Las cadenas de texto son como palabras o frases. Por ejemplo:

```python
nombre = "Ana"
```

La variable "nombre" es una cadena de texto que contiene el nombre "Ana".

#### 4. Booleanos (bool)

Los booleanos son como interruptores que pueden estar encendidos (True) o apagados (False). Por ejemplo:

```python
es_mayor_de_edad = False
```

La variable "es_mayor_de_edad" es un booleano y est√° configurada como False en este caso.

### ¬øPor qu√© son Importantes los Tipos de Datos?

Los tipos de datos son esenciales porque determinan c√≥mo se almacena y se maneja la informaci√≥n en Python. Por ejemplo, no querr√≠as sumar una cadena de texto a un n√∫mero, ¬øverdad? Los tipos de datos te ayudan a evitar errores y a hacer que tu programa funcione de manera correcta.

### Ejemplos Pr√°cticos

Veamos algunos ejemplos m√°s interesantes:

```python
# N√∫meros
num1 = 10
num2 = 5
suma = num1 + num2
print("La suma de", num1, "y", num2, "es igual a", suma)

# Cadenas de Texto
saludo = "¬°Hola, "
nombre = "Mar√≠a!"
mensaje = saludo + nombre
print(mensaje)

# Booleanos
es_mayor_de_edad = edad >= 18
print("¬øEs mayor de edad?", es_mayor_de_edad)
```

¬°Bien hecho! Ahora sabes lo que son las variables y c√≥mo usarlas en Python. Son como cajas m√°gicas donde puedes guardar informaci√≥n importante. Recuerda darles nombres descriptivos para que puedas recordar f√°cilmente lo que contienen.

# Operadores en Python<a name="operadores"></a>

En programaci√≥n, los operadores son herramientas que nos permiten realizar tareas como c√°lculos matem√°ticos, comparar valores y tomar decisiones. Vamos a ver los tipos de operadores m√°s comunes en Python.

#### 1. Operadores Aritm√©ticos

Los operadores aritm√©ticos se utilizan para realizar c√°lculos matem√°ticos. Aqu√≠ tienes algunos ejemplos:

```python
# Suma
resultado_suma = 5 + 3
print("Suma:", resultado_suma)

# Resta
resultado_resta = 10 - 7
print("Resta:", resultado_resta)

# Multiplicaci√≥n
resultado_multiplicacion = 4 * 6
print("Multiplicaci√≥n:", resultado_multiplicacion)

# Divisi√≥n
resultado_division = 12 / 3
print("Divisi√≥n:", resultado_division)

# M√≥dulo (resto de la divisi√≥n)
resultado_modulo = 10 % 3
print("M√≥dulo:", resultado_modulo)
```
- Suma (+): `3 + 5` da como resultado `8`.
- Resta (-): `10 - 7` da como resultado `3`.
- Multiplicaci√≥n (*): `4 * 6` da como resultado `24`.
- Divisi√≥n (/): `12 / 3` da como resultado `4.0` (¬°un flotante!).
- M√≥dulo (%): `10 % 3` da como resultado `1` (el resto de la divisi√≥n).

#### 2. Operadores de Comparaci√≥n

Los operadores de comparaci√≥n se utilizan para comparar valores y devuelven un valor booleano (True o False). Aqu√≠ tienes ejemplos:

```python
# Igual
igual = 5 == 5
print("Igual:", igual)

# No igual
no_igual = 5 != 3
print("No igual:", no_igual)

# Mayor que
mayor_que = 7 > 3
print("Mayor que:", mayor_que)

# Menor que
menor_que = 4 < 2
print("Menor que:", menor_que)

# Mayor o igual que
mayor_o_igual_que = 6 >= 6
print("Mayor o igual que:", mayor_o_igual_que)

# Menor o igual que
menor_o_igual_que = 9 <= 8
print("Menor o igual que:", menor_o_igual_que)
```
- Igual (==): `5 == 5` da como resultado `True`.
- No igual (!=): `5 != 3` da como resultado `True`.
- Mayor que (>): `7 > 3` da como resultado `True`.
- Menor que (<): `4 < 2` da como resultado `False`.
- Mayor o igual que (>=): `6 >= 6` da como resultado `True`.
- Menor o igual que (<=): `9 <= 8` da como resultado `False`.

#### 3. Operadores L√≥gicos

Los operadores l√≥gicos se utilizan para combinar condiciones y tomar decisiones. Aqu√≠ tienes ejemplos:

```python
# Y (and)
condicion_and = True and False
print("Y (and):", condicion_and)

# O (or)
condicion_or = True or False
print("O (or):", condicion_or)

# No (not)
condicion_not = not True
print("No (not):", condicion_not)
```
- Y (and): `True and False` da como resultado `False`.
- O (or): `True or False` da como resultado `True`.
- No (not): `not True` da como resultado `False`.

### **Ejemplo 1: Operaciones Aritm√©ticas**

```python
edad = 12
altura = 1.5
suma = edad + altura

print("Edad:", edad)
print("Altura:", altura)
print("Resultado de la suma:", suma)
```

En este ejemplo, hemos utilizado el operador de suma `+` para sumar la variable `edad` y la variable `altura`. Luego, imprimimos los valores de `edad`, `altura` y el resultado de la suma utilizando la funci√≥n `print()`.

### **Ejemplo 2: Operadores de Comparaci√≥n**

```python
temperatura = 28
es_caluroso = temperatura > 30

print("Temperatura:", temperatura)
print("¬øEs un d√≠a caluroso?", es_caluroso)
```

En este caso, hemos usado el operador de comparaci√≥n "mayor que" (`>`) para verificar si la variable `temperatura` es mayor que 30. Luego, imprimimos el valor de `temperatura` y la variable `es_caluroso` que almacena el resultado de la comparaci√≥n.

### **Ejemplo 3: Operadores L√≥gicos**

```python
es_dia_laboral = True
tengo_clases = True
puedo_ir_al_parque = es_dia_laboral and not tengo_clases

print("¬øEs d√≠a laboral?", es_dia_laboral)
print("¬øTengo clases?", tengo_clases)
print("¬øPuedo ir al parque?", puedo_ir_al_parque)
```

En este tercer ejemplo, hemos utilizado operadores l√≥gicos. Primero, definimos las variables `es_dia_laboral` y `tengo_clases`. Luego, usamos el operador `and` para verificar si ambas condiciones son verdaderas y el operador `not` para negar la segunda condici√≥n. Finalmente, imprimimos los valores de las variables y el resultado de la operaci√≥n l√≥gica.


### Operaciones de Entrada/Salida en Consola en Python



En programaci√≥n, las **operaciones de entrada** son aquellas que permiten al programa recibir datos del usuario, mientras que las **operaciones de salida** se refieren a mostrar informaci√≥n al usuario. En Python, esto se logra principalmente mediante las funciones `input()` para la entrada y `print()` para la salida.

#### Ejemplo Pr√°ctico

Veamos un ejemplo sencillo de c√≥mo Python maneja la entrada y salida de datos en la consola:

```python
name = input("Ingrese su nombre: ")
print(name)
print(type(name))
age = int(input("Ingrese su edad: "))
print(type(age))
```

Este c√≥digo realiza las siguientes acciones:

1. **Entrada de nombre**: La funci√≥n `input("Ingrese su nombre: ")` muestra un mensaje en la consola y espera a que el usuario ingrese su nombre. El valor ingresado se almacena en la variable `name`.
2. **Salida de nombre**: La funci√≥n `print(name)` muestra en la consola el nombre que el usuario ingres√≥.
3. **Tipo de dato**: La funci√≥n `type()` se utiliza para determinar el tipo de dato de `name`, que ser√° `str` (cadena de texto). Este tipo de dato se muestra con `print(type(name))`.
4. **Entrada de edad**: Similar al nombre, `input("Ingrese su edad: ")` solicita al usuario que ingrese su edad. Sin embargo, como `input()` siempre devuelve una cadena de texto, se convierte el valor ingresado en un entero usando `int()`.
5. **Tipo de dato edad**: Nuevamente, `type()` se usa para mostrar que la variable `age` ahora es de tipo `int` (entero), lo cual se confirma con `print(type(age))`.

#### Profundizando en la Entrada y Salida

- **input()**: Esta funci√≥n siempre devuelve el dato ingresado por el usuario como una cadena de texto (`str`), sin importar si el usuario ingresa n√∫meros o letras. Esto significa que, si se necesita un tipo de dato diferente, como un n√∫mero entero (`int`) o un n√∫mero de punto flotante (`float`), es necesario convertir expl√≠citamente el valor devuelto.

- **print()**: Es la funci√≥n est√°ndar para mostrar datos en la consola. Se pueden mostrar m√∫ltiples valores separados por comas, y Python los convertir√° autom√°ticamente a cadenas de texto para su presentaci√≥n.

#### Consideraciones Importantes

1. **Validaci√≥n de entrada**: En aplicaciones reales, es importante validar lo que el usuario ingresa. Por ejemplo, asegurarse de que un n√∫mero realmente sea un n√∫mero antes de intentar convertirlo a un `int`.

2. **Manejo de errores**: Python puede generar un error si se intenta convertir una cadena de texto no num√©rica en un entero, lo que puede manejarse usando excepciones (`try-except`).


## Listas en Python<a name="listas"></a>

Imagina que tienes una caja de LEGO con diferentes piezas. Las listas en Python son como esa caja; te permiten almacenar una colecci√≥n de elementos en un solo lugar. Puedes pensar en ellas como un conjunto de elementos ordenados que puedes modificar, agregar o eliminar seg√∫n tus necesidades.

Vamos a adentrarnos en c√≥mo funcionan las listas en Python:

#### Creaci√≥n de una Lista:

```python
mi_lista = [1, 2, 3, 4, 5]
```

Las listas se crean utilizando corchetes `[]` y los elementos se separan por comas.

#### Ejemplo 1: Creando una Lista de Nombres

```python
nombres = ["Alice", "Bob", "Charlie", "David"]
```

Aqu√≠, creamos una lista de nombres. Puedes acceder a cada nombre por su posici√≥n en la lista.

#### Ejemplo 2: Modificando una Lista

```python
colores = ["rojo", "verde", "azul"]
colores[1] = "amarillo"
```

En este caso, cambiamos el segundo elemento de la lista de "verde" a "amarillo".

En Python, las listas utilizan indexaci√≥n basada en cero, lo que significa que el primer elemento de la lista tiene un √≠ndice de 0, el segundo elemento tiene un √≠ndice de 1, el tercer elemento tiene un √≠ndice de 2 y as√≠ sucesivamente. Por lo tanto, cuando se cambia el valor en la posici√≥n 1 de la lista, se est√° haciendo referencia al segundo elemento de la lista.

La lista `colores` contiene tres elementos:

- El elemento en la posici√≥n 0 es "rojo".
- El elemento en la posici√≥n 1 es "verde".
- El elemento en la posici√≥n 2 es "azul".

Al ejecutar la l√≠nea `colores[1] = "amarillo"`, est√°s reemplazando el valor en la posici√≥n 1 (que es "verde") por "amarillo". Por lo tanto, el segundo elemento de la lista cambia de "verde" a "amarillo", y la lista resultante es `["rojo", "amarillo", "azul"]`.

Es importante recordar que la indexaci√≥n basada en cero es una caracter√≠stica com√∫n en muchos lenguajes de programaci√≥n y puede requerir cierta familiarizaci√≥n para trabajar con listas y otros tipos de secuencias en Python.

#### Ejemplo 3: Agregando y Eliminando Elementos

```python
frutas = ["manzana", "banana", "cereza"]
frutas.append("uva")  # Agregar un elemento al final
frutas.insert(1, "naranja")  # Insertar un elemento en una posici√≥n espec√≠fica
frutas.remove("banana")  # Eliminar un elemento por valor
```

Aqu√≠, mostramos c√≥mo agregar elementos al final o en una posici√≥n espec√≠fica, y c√≥mo eliminar elementos de la lista.


1. **Agregar un elemento al final de la lista:**
   
   La l√≠nea `frutas.append("uva")` agrega la cadena "uva" al final de la lista `frutas`. Como resultado, la lista `frutas` se ver√° as√≠:

   ```python
   ["manzana", "banana", "cereza", "uva"]
   ```

   La funci√≥n `append()` agrega el elemento al final de la lista sin importar la posici√≥n anterior de los elementos.

2. **Insertar un elemento en una posici√≥n espec√≠fica:**

   La l√≠nea `frutas.insert(1, "naranja")` inserta la cadena "naranja" en la posici√≥n 1 de la lista `frutas`. Esto desplaza el elemento anterior en esa posici√≥n hacia la derecha. La lista resultante ser√°:

   ```python
   ["manzana", "naranja", "banana", "cereza", "uva"]
   ```

   La funci√≥n `insert()` toma dos argumentos: la posici√≥n en la que se desea insertar el elemento y el elemento en s√≠.

3. **Eliminar un elemento por valor:**

   La l√≠nea `frutas.remove("banana")` elimina el elemento "banana" de la lista `frutas`. Despu√©s de esta operaci√≥n, la lista se ver√° de la siguiente manera:

   ```python
   ["manzana", "naranja", "cereza", "uva"]
   ```

   La funci√≥n `remove()` busca el valor especificado y elimina la primera ocurrencia de ese valor en la lista. Si hubiera m√∫ltiples "banana" en la lista, solo se eliminar√≠a la primera.

Estas operaciones son esenciales para manipular listas en Python. Puedes agregar elementos al final o en posiciones espec√≠ficas, y tambi√©n eliminar elementos seg√∫n su valor. Es importante tener en cuenta que las listas en Python son flexibles y permiten una amplia gama de operaciones para administrar datos.

¬°Fant√°stico! Ahora conoces las listas en Python y c√≥mo utilizarlas para organizar colecciones de elementos. Las listas son como contenedores vers√°tiles que te permiten trabajar con datos de manera eficiente.




### ¬øQu√© son las Tuplas en Python?<a name="tuplas"></a>

Imagina que tienes una caja de joyas con piedras preciosas que no puedes modificar. Las tuplas en Python son como esas cajas; te permiten almacenar una colecci√≥n de elementos, pero a diferencia de las listas, las tuplas son inmutables, lo que significa que no puedes cambiar su contenido una vez que se crean.

Vamos a adentrarnos en c√≥mo funcionan las tuplas en Python:

#### Creaci√≥n de una Tupla:

```python
mi_tupla = (1, 2, 3, 4, 5)
```

Las tuplas se crean utilizando par√©ntesis `()` y los elementos se separan por comas.

#### Ejemplo 1: Creando una Tupla de Coordenadas

```python
coordenadas = (3, 4)
```

Aqu√≠, creamos una tupla que representa las coordenadas (3, 4).Esto puede ser √∫til, por ejemplo, en geometr√≠a para representar puntos en un plano.

#### Ejemplo 2: Intentando Modificar una Tupla

```python
mi_tupla = (1, 2, 3)
mi_tupla[1] = 5  # ¬°Esto generar√° un error!
```

En este caso, intentamos modificar el segundo elemento de la tupla, pero como mencion√© antes, las tuplas son inmutables, por lo que generar√° un error.

#### Ejemplo 3: Usando Tuplas en Funciones

```python
def dividir_y_redondear(numero1, numero2):
    cociente = numero1 / numero2
    resto = numero1 % numero2
    return (cociente, resto)

resultado = dividir_y_redondear(10, 3)
print("Cociente:", resultado[0])
print("Resto:", resultado[1])
```

En este √∫ltimo ejemplo, hemos definido una funci√≥n llamada `dividir_y_redondear` que toma dos n√∫meros como entrada, realiza una divisi√≥n y c√°lculo de resto, y devuelve una tupla con los resultados. Luego, llamamos a la funci√≥n con los valores 10 y 3, y almacenamos la tupla resultante en la variable `resultado`. Finalmente, imprimimos el cociente y el resto accediendo a los elementos de la tupla utilizando la indexaci√≥n, es decir, `resultado[0]` para el cociente y `resultado[1]` para el resto. Las tuplas son √∫tiles para devolver m√∫ltiples valores desde una funci√≥n.

### ¬øQu√© son los Diccionarios en Python?<a name="diccionario"></a>

Imagina que tienes un cuaderno donde puedes anotar definiciones de palabras junto con sus significados. Los diccionarios en Python son como ese cuaderno; te permiten almacenar pares de "palabra" (clave) y "definici√≥n" (valor). Los diccionarios son una forma eficiente de gestionar datos estructurados.

Vamos a adentrarnos en c√≥mo funcionan los diccionarios en Python:

#### Creaci√≥n de un Diccionario:

```python
mi_diccionario = {"manzana": "una fruta roja y deliciosa", "coche": "un veh√≠culo de cuatro ruedas"}
```

Los diccionarios se crean utilizando llaves `{}` y los pares clave-valor se separan por comas.

#### Ejemplo 1: Accediendo a un Valor por Clave

```python
mi_diccionario = {"manzana": "una fruta roja y deliciosa", "coche": "un veh√≠culo de cuatro ruedas"}
print("Significado de 'manzana':", mi_diccionario["manzana"])
```

En este ejemplo, hemos creado un diccionario llamado `mi_diccionario` con dos pares clave-valor. La clave "manzana" se asocia con el valor "una fruta roja y deliciosa", y la clave "coche" se asocia con el valor "un veh√≠culo de cuatro ruedas".

Para acceder al valor asociado con una clave espec√≠fica, utilizamos la sintaxis de corchetes y proporcionamos la clave. En este caso:

```python
print("Significado de 'manzana':", mi_diccionario["manzana"])
```

La l√≠nea de c√≥digo anterior imprime el significado de la palabra "manzana" en nuestro "diccionario". En otras palabras, estamos accediendo al valor asociado con la clave "manzana" en el diccionario `mi_diccionario`.

Este enfoque es muy √∫til cuando necesitas buscar informaci√≥n asociada con una clave espec√≠fica en un conjunto de datos, como definiciones en un diccionario o datos en una base de datos. Los diccionarios son una de las estructuras de datos m√°s vers√°tiles en Python y se utilizan ampliamente en la programaci√≥n para el almacenamiento y recuperaci√≥n eficiente de informaci√≥n.

#### Ejemplo 2: Agregando o Modificando Elementos
En Python, los diccionarios son estructuras de datos flexibles que permiten almacenar pares clave-valor. Puedes agregar nuevos elementos a un diccionario o modificar los valores existentes asociados con una clave espec√≠fica. 

```python
mi_diccionario = {"manzana": "una fruta roja y deliciosa", "coche": "un veh√≠culo de cuatro ruedas"}
mi_diccionario["bicicleta"] = "un veh√≠culo de dos ruedas"
mi_diccionario["coche"] = "un veh√≠culo de transporte motorizado"
```

#### **Agregando un Elemento:**

```python
mi_diccionario["bicicleta"] = "un veh√≠culo de dos ruedas"
```

En esta l√≠nea, estamos agregando un nuevo elemento al diccionario. La clave es "bicicleta" y el valor asociado es "un veh√≠culo de dos ruedas". El diccionario ahora contendr√° tres elementos.

#### **Modificando un Elemento:**

```python
mi_diccionario["coche"] = "un veh√≠culo de transporte motorizado"
```

Aqu√≠, estamos modificando el valor asociado con la clave "coche". Originalmente, "coche" estaba relacionado con "un veh√≠culo de cuatro ruedas", pero hemos actualizado el valor a "un veh√≠culo de transporte motorizado".

Despu√©s de estas operaciones, el diccionario `mi_diccionario` se ver√° as√≠:

```python
{
    "manzana": "una fruta roja y deliciosa",
    "coche": "un veh√≠culo de transporte motorizado",
    "bicicleta": "un veh√≠culo de dos ruedas"
}
```

Este ejemplo ilustra c√≥mo los diccionarios en Python te permiten agregar nuevas entradas o actualizar los valores existentes con facilidad. Las claves deben ser √∫nicas en un diccionario, pero los valores pueden ser cualquier tipo de dato. Los diccionarios son una herramienta poderosa para organizar y manipular datos en programas Python.

#### Ejemplo 3: Recorriendo un Diccionario

```python
mi_diccionario = {"manzana": "una fruta roja y deliciosa", "coche": "un veh√≠culo de cuatro ruedas"}

for clave, valor in mi_diccionario.items():
    print("La", clave, "es", valor)
```

En este caso, recorremos el diccionario y mostramos todas las claves y sus respectivos valores.


En este fragmento de c√≥digo, hemos utilizado un bucle `for` para recorrer el diccionario `mi_diccionario`. La funci√≥n `items()` se usa para obtener pares clave-valor del diccionario. En cada iteraci√≥n del bucle, la variable `clave` toma el valor de una clave y la variable `valor` toma el valor asociado con esa clave.

Dentro del bucle, estamos imprimiendo una oraci√≥n que describe el par clave-valor. Por ejemplo, en la primera iteraci√≥n, el bucle imprime "La manzana es una fruta roja y deliciosa". En la segunda iteraci√≥n, imprimir√° "El coche es un veh√≠culo de cuatro ruedas".

Este enfoque es √∫til cuando necesitas realizar una acci√≥n o procesamiento en cada elemento del diccionario. Puedes acceder tanto a las claves como a los valores de forma individual y realizar tareas espec√≠ficas en cada uno de ellos. Los bucles `for` junto con el m√©todo `items()` hacen que trabajar con diccionarios sea muy conveniente en Python.

¬°Fant√°stico! Ahora conoces los diccionarios en Python y c√≥mo utilizarlos para organizar datos estructurados de manera eficiente. Los diccionarios son como tu propio libro de definiciones personal.

## Estructuras de Control en Python<a name="estructuras"></a>

Las estructuras de control son como las herramientas que nos permiten tomar decisiones y repetir acciones en nuestros programas. Imagina que eres un director de orquesta y tienes que dirigir a los m√∫sicos para que toquen en armon√≠a. Las estructuras de control en Python son como tu batuta m√°gica que te permite dirigir el flujo de un programa. Te ayudan a tomar decisiones y repetir acciones seg√∫n sea necesario.

Vamos a conocer dos tipos principales de estructuras de control en Python:

### 1. Condicionales (if)<a name="estructura-if"></a>

Imagina que tienes un interruptor en tu habitaci√≥n que enciende o apaga una luz. Las sentencias "if" en Python son como ese interruptor; te permiten tomar decisiones en tus programas. Puedes decirle a tu programa qu√© hacer si se cumple una condici√≥n y qu√© hacer si no.

Vamos a profundizar en c√≥mo funcionan las sentencias "if" en Python:

#### Sintaxis de la Sentencia "if":

```python
if condici√≥n:
    # C√≥digo a ejecutar si la condici√≥n es verdadera
else:
    # C√≥digo a ejecutar si la condici√≥n es falsa
```

Las sentencias "if" se utilizan para evaluar si una condici√≥n es verdadera o falsa. Si la condici√≥n es verdadera, se ejecuta el bloque de c√≥digo debajo del "if". Si es falsa, se ejecuta el bloque de c√≥digo bajo el "else" (si est√° presente).

La estructura de control condicional (if) te permite tomar decisiones en tu programa. Aqu√≠ tienes unos ejemplos pr√°cticos:

#### Ejemplo 1: Evaluando una Edad

```python
edad = 12

if edad < 18:
    print("Eres menor de edad.")
else:
    print("Eres mayor de edad.")
```

En este caso, el programa verifica si la edad es menor de 18 y muestra un mensaje adecuado.

#### Ejemplo 2: Verificando un N√∫mero Par

```python
numero = 7

if numero % 2 == 0:
    print("El n√∫mero es par.")
else:
    print("El n√∫mero es impar.")
```

Aqu√≠, el programa verifica si un n√∫mero es par o impar y muestra un mensaje en consecuencia.

¬°Magn√≠fico! Ahora conoces las sentencias "if" en Python y c√≥mo usarlas para tomar decisiones en tus programas. Estas sentencias son como las instrucciones que das a tu programa para que tome caminos diferentes seg√∫n las condiciones.

### 2. Estructura de Control de Bucle (for)<a name="ciclo-for"></a>

Imagina que tienes una lista de tareas y quieres realizar una acci√≥n para cada elemento de la lista. El bucle "for" en Python es como tu asistente personal que te ayuda a recorrer y realizar acciones en cada elemento de una secuencia, como una lista o una cadena de texto.

Vamos a adentrarnos en c√≥mo funciona el bucle "for" en Python:

#### Sintaxis del Bucle "for":

```python
for elemento in secuencia:
    # C√≥digo a ejecutar para cada elemento
```

El bucle "for" se utiliza para iterar a trav√©s de una secuencia (como una lista) y ejecutar un bloque de c√≥digo para cada elemento en esa secuencia.

La estructura de control de bucle (for) te permite repetir acciones un n√∫mero espec√≠fico de veces. Por ejemplo:
#### Ejemplo 1: Iterando a trav√©s de una Lista

```python
nombres = ["Alice", "Bob", "Charlie", "David"]

for nombre in nombres:
    print("Hola,", nombre)
```

En este caso, el bucle "for" recorre la lista de nombres y saluda a cada persona.

#### Ejemplo 2: Contando Hasta un N√∫mero

```python
numero_limite = 5

for numero in range(numero_limite):
    print("N√∫mero:", numero)
```

Aqu√≠, el bucle "for" cuenta desde 0 hasta el n√∫mero l√≠mite.

¬°Fant√°stico! Ahora conoces el bucle "for" en Python y c√≥mo usarlo para recorrer secuencias y realizar acciones en cada elemento. El bucle "for" es como un explorador que te gu√≠a a trav√©s de un mapa de datos.

#### 3. Estructura de Control de Bucle (while)<a name="ciclo-while"></a>

Imagina que est√°s buscando un tesoro y sigues buscando hasta que encuentras una "X" en el mapa. El bucle "while" en Python es como tu b√∫squeda de tesoro; te permite repetir una acci√≥n mientras se cumpla una condici√≥n.

Vamos a explorar c√≥mo funciona el bucle "while" en Python:

#### Sintaxis del Bucle "while":

```python
while condici√≥n:
    # C√≥digo a ejecutar mientras se cumpla la condici√≥n
```

El bucle "while" se utiliza para repetir un bloque de c√≥digo mientras una condici√≥n sea verdadera. Si la condici√≥n se vuelve falsa en alg√∫n momento, el bucle se detiene.


#### Ejemplo 1: Contando Hasta un N√∫mero

```python
numero = 1

while numero <= 5:
    print("N√∫mero:", numero)
    numero += 1
```

En este caso, el bucle "while" cuenta desde 1 hasta 5 y muestra los n√∫meros.

#### Ejemplo 2: Adivinando un N√∫mero

```python
numero_secreto = 7
intentos = 0

while True:
    intento = int(input("Adivina el n√∫mero secreto: "))
    intentos += 1

    if intento == numero_secreto:
        print("¬°Correcto! ¬°Lo adivinaste en", intentos, "intentos!")
        break
```

Aqu√≠, el bucle "while" permite adivinar un n√∫mero secreto y se detiene cuando se adivina correctamente.

¬°Incre√≠ble! Ahora conoces el bucle "while" en Python y c√≥mo usarlo para repetir acciones mientras se cumple una condici√≥n. El bucle "while" es como una b√∫squeda emocionante que contin√∫a hasta que se alcanza el objetivo.

# Funciones<a name="funciones"></a>

Las funciones son bloques de c√≥digo reutilizable que te ayudan a organizar y simplificar tu programa.

Imagina que tienes un libro de recetas y cada receta es una serie de pasos para cocinar un delicioso platillo. Las funciones en Python son como esas recetas; te permiten agrupar un conjunto de instrucciones en un solo lugar y darle un nombre. Esto hace que tu programa sea m√°s organizado y f√°cil de entender.

Vamos a descubrir c√≥mo funcionan las funciones en Python:

#### Sintaxis de una Funci√≥n en Python:

```python
def nombre_de_la_funcion(parametro1, parametro2):
    # C√≥digo a ejecutar
    resultado = parametro1 + parametro2
    return resultado
```

- `def`: Esta palabra clave se utiliza para definir una funci√≥n en Python.
- `nombre_de_la_funcion`: Es el nombre que eliges para tu funci√≥n.
- `parametro1` y `parametro2`: Son valores que puedes pasar a la funci√≥n para que los use en su interior.
- `return`: Es la palabra clave que se utiliza para devolver un valor desde la funci√≥n.

#### Ejemplo 1: Funci√≥n que Saluda

```python
def saludar(nombre):
    mensaje = "¬°Hola, " + nombre + "!"
    return mensaje

nombre_usuario = "Alice"
saludo = saludar(nombre_usuario)
print(saludo)
```

En este caso, creamos una funci√≥n llamada `saludar` que toma un nombre como par√°metro y devuelve un mensaje de saludo.

#### Ejemplo 2: Funci√≥n que Calcula el Cuadrado

```python
def calcular_cuadrado(numero):
    cuadrado = numero * numero
    return cuadrado

numero_ingresado = 5
resultado = calcular_cuadrado(numero_ingresado)
print("El cuadrado de", numero_ingresado, "es", resultado)
```

Aqu√≠, creamos una funci√≥n llamada `calcular_cuadrado` que toma un n√∫mero como par√°metro y devuelve su cuadrado.

¬°Excelente trabajo! Ahora conoces las funciones en Python y c√≥mo usarlas para agrupar y reutilizar c√≥digo. Las funciones son como herramientas que puedes utilizar una y otra vez en diferentes partes de tu programa.


# Funciones Lambda


En Python, una funci√≥n lambda es una funci√≥n an√≥nima, lo que significa que no tiene un nombre definido. A diferencia de las funciones tradicionales definidas con `def`, las funciones lambda est√°n dise√±adas para tareas simples y r√°pidas, donde una funci√≥n completa podr√≠a ser excesiva.

La sintaxis b√°sica de una funci√≥n lambda es:

```python
lambda argumentos: expresi√≥n
```

Donde:
- `argumentos`: Son los par√°metros que la funci√≥n lambda acepta.
- `expresi√≥n`: Es una √∫nica expresi√≥n que se eval√∫a y se devuelve como resultado.

**Ejemplo Simple:**

```python
suma = lambda x, y: x + y
resultado = suma(5, 3)
print(resultado)  # Output: 8
```

En este ejemplo, la funci√≥n lambda toma dos argumentos (`x` y `y`) y devuelve su suma. A diferencia de las funciones tradicionales, la funci√≥n lambda se define y se utiliza en una sola l√≠nea.

#### Ventajas de Usar Funciones Lambda

1. **Concisi√≥n:** Las funciones lambda permiten escribir c√≥digo m√°s compacto, eliminando la necesidad de definir funciones completas para operaciones simples.
   
2. **Flexibilidad:** Son √∫tiles cuando se necesita una funci√≥n temporal que solo se va a usar una vez o en un contexto espec√≠fico, como argumentos para otras funciones.

3. **Legibilidad:** Aunque pueden hacer que el c√≥digo sea m√°s denso, cuando se usan correctamente, las funciones lambda pueden hacer que las operaciones simples sean m√°s f√°ciles de entender.

#### Aplicaciones Comunes de las Funciones Lambda

Las funciones lambda son especialmente √∫tiles en combinaci√≥n con otras funciones de Python que aceptan funciones como argumentos, como `map()`, `filter()`, y `sorted()`.

**1. Usando `map()` con Lambda:**

La funci√≥n `map()` aplica una funci√≥n a cada elemento de un iterable (como una lista). Aqu√≠ es donde las funciones lambda brillan.

```python
numeros = [1, 2, 3, 4]
cuadrados = list(map(lambda x: x ** 2, numeros))
print(cuadrados)  # Output: [1, 4, 9, 16]
```

En este ejemplo, la funci√≥n lambda eleva cada n√∫mero de la lista `numeros` al cuadrado, generando una nueva lista de resultados.

**2. Usando `filter()` con Lambda:**

La funci√≥n `filter()` filtra elementos de un iterable seg√∫n una condici√≥n definida por una funci√≥n.

```python
numeros = [1, 2, 3, 4, 5, 6]
pares = list(filter(lambda x: x % 2 == 0, numeros))
print(pares)  # Output: [2, 4, 6]
```

Aqu√≠, la funci√≥n lambda devuelve `True` solo para los n√∫meros que son divisibles por 2, filtrando as√≠ los n√∫meros pares de la lista.

**3. Usando `sorted()` con Lambda:**

La funci√≥n `sorted()` puede ordenar elementos en una secuencia seg√∫n una clave proporcionada por una funci√≥n.

```python
frutas = ['manzana', 'kiwi', 'banana', 'cereza']
ordenadas = sorted(frutas, key=lambda x: len(x))
print(ordenadas)  # Output: ['kiwi', 'banana', 'cereza', 'manzana']
```

En este ejemplo, la lista `frutas` se ordena en funci√≥n de la longitud de cada palabra, utilizando una funci√≥n lambda como clave de ordenaci√≥n.

#### Cu√°ndo Evitar las Funciones Lambda

Aunque las funciones lambda son √∫tiles, no siempre son la mejor opci√≥n. Si la operaci√≥n que est√°s realizando es compleja o si la funci√≥n lambda comienza a ser dif√≠cil de leer, es mejor definir una funci√≥n normal con `def`.

Por ejemplo, una funci√≥n lambda muy larga o anidada puede ser dif√≠cil de entender y mantener:

```python
complicada = lambda x: (x ** 2 + x + 1) if x > 0 else (x ** 2 - x + 1)
```

Este tipo de funci√≥n es mejor manejarlo con una definici√≥n de funci√≥n tradicional:

```python
def complicada(x):
    if x > 0:
        return x ** 2 + x + 1
    else:
        return x ** 2 - x + 1
```


## Funciones `map()`, `filter()`, y `sorted()`

#### `map()`: Transformando Colecciones

La funci√≥n `map()` es una herramienta que te permite aplicar una funci√≥n a cada elemento de un iterable (como una lista o una tupla) y devuelve un nuevo iterable con los resultados. Es como tener un asistente que transforma cada √≠tem de una lista seg√∫n tus instrucciones, sin que tengas que escribir un bucle expl√≠cito.

**Sintaxis:**

```python
map(funci√≥n, iterable)
```

- `funci√≥n`: Una funci√≥n que se aplica a cada elemento del iterable.
- `iterable`: La colecci√≥n de datos que quieres transformar.

**Ejemplo con `map()`:**

```python
numeros = [1, 2, 3, 4, 5]
cuadrados = list(map(lambda x: x ** 2, numeros))
print(cuadrados)  # Output: [1, 4, 9, 16, 25]
```

En este ejemplo, la funci√≥n `lambda x: x ** 2` se aplica a cada n√∫mero en la lista `numeros`, creando una nueva lista con los n√∫meros elevados al cuadrado.

**¬øCu√°ndo usar `map()`?**

Usa `map()` cuando necesites transformar todos los elementos de una colecci√≥n de manera uniforme. Es particularmente √∫til cuando tienes una funci√≥n que realiza una operaci√≥n simple y deseas aplicarla a toda una colecci√≥n sin tener que escribir un bucle expl√≠cito.

#### `filter()`: Filtrando Colecciones

Mientras que `map()` transforma colecciones, `filter()` selecciona elementos de una colecci√≥n que cumplen con una determinada condici√≥n. Imagina que tienes una lista de n√∫meros y solo quieres los pares. `filter()` te permite hacer esto de manera elegante y eficiente.

**Sintaxis:**

```python
filter(funci√≥n, iterable)
```

- `funci√≥n`: Una funci√≥n que devuelve `True` o `False` para determinar si un elemento debe incluirse en el nuevo iterable.
- `iterable`: La colecci√≥n de datos que quieres filtrar.

**Ejemplo con `filter()`:**

```python
numeros = [1, 2, 3, 4, 5, 6]
pares = list(filter(lambda x: x % 2 == 0, numeros))
print(pares)  # Output: [2, 4, 6]
```

Aqu√≠, `filter()` selecciona solo los n√∫meros que son divisibles por 2, devolviendo una lista con los n√∫meros pares.

**¬øCu√°ndo usar `filter()`?**

`filter()` es ideal cuando necesitas reducir una colecci√≥n a solo los elementos que cumplen con una condici√≥n espec√≠fica. Es perfecto para situaciones donde un bucle `for` y una declaraci√≥n `if` har√≠an el trabajo, pero quieres un enfoque m√°s limpio y conciso.

#### `sorted()`: Ordenando Colecciones

La funci√≥n `sorted()` te permite ordenar una colecci√≥n de datos. No solo ordena de manera ascendente o descendente, sino que tambi√©n te permite especificar criterios personalizados para ordenar, como la longitud de cadenas o valores espec√≠ficos de diccionarios.

**Sintaxis:**

```python
sorted(iterable, key=None, reverse=False)
```

- `iterable`: La colecci√≥n de datos que quieres ordenar.
- `key`: (Opcional) Una funci√≥n que sirve como clave para la ordenaci√≥n.
- `reverse`: (Opcional) Un booleano que indica si la ordenaci√≥n debe ser en orden descendente.

**Ejemplo con `sorted()`:**

```python
frutas = ['manzana', 'pera', 'banana', 'cereza']
ordenadas = sorted(frutas, key=lambda x: len(x))
print(ordenadas)  # Output: ['pera', 'banana', 'cereza', 'manzana']
```

En este ejemplo, las frutas se ordenan seg√∫n la longitud de sus nombres.

**¬øCu√°ndo usar `sorted()`?**

Usa `sorted()` cuando necesites ordenar datos. Es √∫til para organizar listas en orden ascendente, descendente, o bajo un criterio espec√≠fico. Tambi√©n es excelente cuando trabajas con datos complejos y necesitas ordenar seg√∫n una propiedad particular.

#### Combinando `map()`, `filter()`, y `sorted()`

Una de las mayores ventajas de `map()`, `filter()`, y `sorted()` es que pueden combinarse para crear flujos de datos altamente eficientes. Por ejemplo, imagina que tienes una lista de n√∫meros y quieres primero filtrar los n√∫meros pares, luego elevarlos al cuadrado, y finalmente ordenarlos en orden descendente:

**Ejemplo de combinaci√≥n:**

```python
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

resultado = sorted(
    map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numeros)),
    reverse=True
)

print(resultado)  # Output: [100, 64, 36, 16, 4]
```

Este c√≥digo primero filtra los n√∫meros pares, luego los eleva al cuadrado, y finalmente los ordena en orden descendente.


### Matrices

Las matrices son estructuras fundamentales en programaci√≥n que permiten organizar datos en filas y columnas. En Python, se pueden representar f√°cilmente con listas anidadas, ofreciendo una forma intuitiva de trabajar con datos bidimensionales. Este blog explorar√° c√≥mo las matrices pueden utilizarse para representar tableros de juego como ajedrez y damas, manipular im√°genes en escala de grises, y sus aplicaciones en otros campos como la inteligencia artificial y la computaci√≥n cient√≠fica.

### Representaci√≥n de Tableros de Juego

Las matrices son ideales para representar tableros de juego en programaci√≥n. Usar matrices para estos fines facilita la disposici√≥n de piezas y la implementaci√≥n de reglas del juego. Veamos c√≥mo esto se aplica en dos juegos cl√°sicos: ajedrez y damas.

**Ejemplo: Tablero de Ajedrez**

Un tablero de ajedrez es una matriz de 8x8 que puede usarse para representar las piezas del juego. Para este ejemplo, utilizamos letras para representar las piezas: `P` para pe√≥n, `R` para torre, `N` para caballo (knight), `B` para alfil, `Q` para reina y `K` para rey. Las piezas negras se representan con letras min√∫sculas y las blancas con letras may√∫sculas.

```python
chess_board = [
    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
]

print(chess_board)
```

En este ejemplo, el `0` representa una casilla vac√≠a. Esta matriz inicializa el tablero de ajedrez con todas las piezas en sus posiciones correctas.

**Movimiento de un Caballo**

Los caballos (N para blanco y n para negro) se mueven en forma de ‚ÄúL‚Äù. Por ejemplo, si el caballo blanco est√° en la posici√≥n `(7, 1)` (segunda casilla de la √∫ltima fila), las posiciones posibles a las que puede moverse son:

- `(5, 0)`
- `(5, 2)`
- `(6, 3)`

Podemos mover el caballo a una posici√≥n v√°lida y actualizar el tablero:

```python
chess_board[7][1] = 0  # Casilla original del caballo ahora est√° vac√≠a
chess_board[5][2] = 'N'  # Nueva posici√≥n del caballo

print(chess_board)
```

Esto actualiza la matriz para reflejar el nuevo estado del tablero despu√©s del movimiento.

**Ejemplo: Tablero de Damas**

Un tablero de damas tambi√©n es una matriz de 8x8, pero con una representaci√≥n ligeramente diferente para las piezas.

```python
checkers_board = [
    [0, 'b', 0, 'b', 0, 'b', 0, 'b'],
    ['b', 0, 'b', 0, 'b', 0, 'b', 0],
    [0, 'b', 0, 'b', 0, 'b', 0, 'b'],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    ['w', 0, 'w', 0, 'w', 0, 'w', 0],
    [0, 'w', 0, 'w', 0, 'w', 0, 'w'],
    ['w', 0, 'w', 0, 'w', 0, 'w', 0]
]

print(checkers_board)
```

En este ejemplo, el `0` representa una casilla vac√≠a, `'w'` representa una pieza blanca, y `'b'` representa una pieza negra.

### Aplicaci√≥n de Matrices a Im√°genes

Las matrices tambi√©n son esenciales para la representaci√≥n y manipulaci√≥n de im√°genes. Cada p√≠xel de una imagen en escala de grises se puede representar como un valor en una matriz, donde cada valor var√≠a del 0 (negro) al 255 (blanco).

**Ejemplo: Representaci√≥n de una Imagen en Escala de Grises**

Imaginemos una matriz de 5x5 que representa una imagen en escala de grises con un simple patr√≥n.

```python
image = [
    [255, 0, 0, 0, 255],
    [0, 255, 0, 255, 0],
    [0, 0, 255, 0, 0],
    [0, 255, 0, 255, 0],
    [255, 0, 0, 0, 255]
]

print(image)
```

En esta matriz, el `255` representa p√≠xeles blancos y el `0` representa p√≠xeles negros. Este patr√≥n podr√≠a visualizarse como una ‚ÄúX‚Äù blanca sobre un fondo negro si se dibujara.

### Aplicaciones en Otros Campos

Las matrices se utilizan en muchos otros campos adem√°s de los juegos y las im√°genes:

- **An√°lisis de Datos:** Para almacenar y manipular grandes conjuntos de datos y realizar c√°lculos estad√≠sticos.
- **Inteligencia Artificial y Machine Learning:** Representan datos de entrada y salida, pesos de redes neuronales y par√°metros en algoritmos de aprendizaje autom√°tico.
- **Computaci√≥n Cient√≠fica:** Para resolver ecuaciones lineales, realizar simulaciones y modelar fen√≥menos cient√≠ficos.
- **Gr√°ficos por Computadora:** Representan y transforman objetos en gr√°ficos 2D y 3D.


# M√≥dulos<a name="modulos"></a>

Imagina que est√°s construyendo una ciudad y necesitas diferentes tipos de edificios: escuelas, hospitales, y m√°s. Los m√≥dulos en Python son como esos edificios especializados que puedes agregar a tu ciudad de Python. Cada m√≥dulo contiene funciones y variables que puedes utilizar en tu programa.

Vamos a descubrir c√≥mo funcionan los m√≥dulos en Python:

#### Importando un M√≥dulo:

```python
import nombre_del_modulo
```

Para usar un m√≥dulo en Python, primero debes importarlo. Esto te permite acceder a las funciones y variables que contiene.

#### Ejemplo 1: Usando el M√≥dulo "math"

```python
import math

# Calculando la ra√≠z cuadrada
numero = 25
raiz = math.sqrt(numero)
print("La ra√≠z cuadrada de", numero, "es", raiz)

# Calculando el seno
angulo = 45
seno = math.sin(math.radians(angulo))
print("El seno de", angulo, "grados es", seno)
```

En este caso, importamos el m√≥dulo "math" y utilizamos sus funciones para calcular la ra√≠z cuadrada y el seno de un n√∫mero.

#### Ejemplo 2: Usando el M√≥dulo Personalizado

Supongamos que tienes un archivo llamado "mi_modulo.py" con el siguiente contenido:

```python
# mi_modulo.py

def saludar(nombre):
    return "¬°Hola, " + nombre + "!"

def doble(numero):
    return numero * 2
```

Ahora, puedes usar este m√≥dulo personalizado en tu programa principal:

```python
import mi_modulo

nombre = "Alice"
saludo = mi_modulo.saludar(nombre)
print(saludo)

numero = 5
resultado = mi_modulo.doble(numero)
print("El doble de", numero, "es", resultado)
```

Aqu√≠, importamos el m√≥dulo personalizado "mi_modulo.py" y utilizamos sus funciones en nuestro programa principal.

¬°Fant√°stico! Ahora conoces los m√≥dulos en Python y c√≥mo usarlos para aprovechar funciones y variables adicionales. Los m√≥dulos son como tesoros de c√≥digo que puedes agregar a tu programa para hacerlo m√°s poderoso.


# Recursividad

La recursividad es una t√©cnica fundamental en programaci√≥n donde una funci√≥n se llama a s√≠ misma para resolver problemas complejos de manera m√°s sencilla y estructurada.

### ¬øC√≥mo se aplica la recursividad en el c√°lculo del factorial?
La recursividad se entiende mejor con ejemplos pr√°cticos. El factorial de un n√∫mero se define como el producto de todos los n√∫meros desde ese n√∫mero hasta 1. Por ejemplo, el factorial de 5 (5!) es 5 * 4 * 3 * 2 * 1.

En c√≥digo Python, la funci√≥n factorial se puede definir recursivamente de la siguiente manera:

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

Este c√≥digo sigue dos casos clave en la recursividad:

Caso base: cuando `n` es 0, la funci√≥n retorna 1.
Caso recursivo: cuando `n` es mayor que 0, la funci√≥n retorna `n` multiplicado por el factorial de `n-1`.

### ¬øC√≥mo funciona la recursividad en la serie de Fibonacci?

La serie de Fibonacci es otra aplicaci√≥n cl√°sica de la recursividad. En esta serie, cada n√∫mero es la suma de los dos anteriores, comenzando con 0 y 1. La f√≥rmula es:

[ F(n) = F(n-1) + F(n-2) ]

El c√≥digo Python para calcular el n√∫mero n-√©simo en la serie de Fibonacci usando recursividad es el siguiente:

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
```        





# Excepciones<a name="excepciones"></a>

Imagina que est√°s cocinando tu plato favorito y te das cuenta de que te falta un ingrediente importante. Las excepciones en Python son como esos momentos inesperados en la programaci√≥n donde algo sale mal, y necesitas manejar la situaci√≥n de manera elegante.

Vamos a descubrir c√≥mo funcionan las excepciones en Python:

#### Uso de `try` y `except`:

```python
try:
    # C√≥digo que podr√≠a generar una excepci√≥n
except TipoDeExcepcion:
    # C√≥digo a ejecutar si se produce una excepci√≥n del tipo especificado
```

- `try`: Este bloque contiene el c√≥digo que podr√≠a generar una excepci√≥n.
- `except`: Si ocurre una excepci√≥n del tipo especificado, este bloque se ejecuta para manejarla.

#### Ejemplo 1: Manejando una Divisi√≥n por Cero

```python
try:
    numerador = 10
    denominador = 0
    resultado = numerador / denominador
except ZeroDivisionError:
    print("¬°Error! No puedes dividir entre cero.")
else:
    print("El resultado es:", resultado)
```

En este caso, utilizamos `try` y `except` para manejar una posible excepci√≥n cuando intentamos dividir por cero.

#### Ejemplo 2: Manejando un Valor no Num√©rico

```python
try:
    entrada = input("Ingresa un n√∫mero: ")
    numero = float(entrada)
except ValueError:
    print("¬°Error! Debes ingresar un n√∫mero v√°lido.")
else:
    print("El n√∫mero ingresado es:", numero)
```

Aqu√≠, usamos `try` y `except` para manejar la posibilidad de que el usuario ingrese un valor que no sea num√©rico.

¬°Excelente trabajo! Ahora conoces c√≥mo manejar excepciones en Python utilizando `try` y `except`. Esto te permite lidiar con situaciones inesperadas de manera controlada y elegante en tus programas.

Con esto, completamos nuestra primera semana de aprendizaje de Python. ¬°Esperamos que estos conceptos te ayuden a dar tus primeros pasos en la programaci√≥n con Python! En la pr√≥xima semana, continuaremos explorando m√°s elementos emocionantes de Python, como listas, diccionarios y m√°s.




### ¬øQu√© son los Conjuntos en Python?<a name="conjuntos"></a>

Imagina que tienes una colecci√≥n de gemas preciosas y quieres asegurarte de que no haya duplicados. Los conjuntos en Python son como esa colecci√≥n; te permiten almacenar elementos √∫nicos y no duplicados. Son una excelente opci√≥n cuando necesitas mantener una lista de elementos distintos.

Vamos a adentrarnos en c√≥mo funcionan los conjuntos en Python:

#### Creaci√≥n de un Conjunto:

```python
mi_conjunto = {1, 2, 3, 4, 5}
```

Los conjuntos se crean utilizando llaves `{}` y los elementos se separan por comas.

#### Ejemplo 1: Creando un Conjunto de Colores

```python
colores = {"rojo", "verde", "azul"}
```

Aqu√≠, creamos un conjunto de colores. Los elementos en un conjunto no tienen un orden espec√≠fico.

#### Ejemplo 2: Agregando y Eliminando Elementos

```python
frutas = {"manzana", "banana", "cereza"}
frutas.add("uva")  # Agregar un elemento al conjunto
frutas.remove("banana")  # Eliminar un elemento del conjunto
```

En este caso, mostramos c√≥mo agregar elementos al conjunto y c√≥mo eliminar elementos del conjunto.

#### Ejemplo 3: Realizando Operaciones de Conjuntos

```python
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

union = A | B  # Uni√≥n de conjuntos
interseccion = A & B  # Intersecci√≥n de conjuntos
diferencia = A - B  # Diferencia de conjuntos

print("Uni√≥n:", union)
print("Intersecci√≥n:", interseccion)
print("Diferencia:", diferencia)
```

En este ejemplo, realizamos operaciones de conjuntos como uni√≥n, intersecci√≥n y diferencia.

¬°Excelente trabajo! Ahora conoces los conjuntos en Python y c√≥mo utilizarlos para mantener una colecci√≥n de elementos √∫nicos. Los conjuntos son como cofres de tesoros que no permiten duplicados.

### Manejo de Archivos<a name="manejo-archivos"></a>

Imagina que tienes un diario donde escribes tus pensamientos y experiencias. En programaci√≥n, los archivos son como esos diarios; te permiten almacenar y recuperar informaci√≥n de manera persistente. El manejo de archivos es esencial para tareas como leer datos de un archivo, escribir resultados o mantener registros de tu programa.

Vamos a adentrarnos en c√≥mo funciona el manejo de archivos en Python:

#### Apertura de un Archivo:

```python
archivo = open("mi_archivo.txt", "r")  # Abre el archivo para lectura (read)
```

- `open`: La funci√≥n `open` se utiliza para abrir un archivo.
- `"mi_archivo.txt"`: Es el nombre del archivo que deseamos abrir.
- `"r"`: Indica que queremos abrir el archivo en modo lectura. Otros modos incluyen "w" para escritura (write) y "a" para agregar contenido (append).

#### Ejemplo 1: Leer Contenido de un Archivo

```python
with open("mi_archivo.txt", "r") as archivo:
    contenido = archivo.read()
    print(contenido)
```

En este caso, abrimos el archivo en modo lectura y leemos su contenido.

#### Ejemplo 2: Escribir en un Archivo

```python
with open("mi_archivo.txt", "w") as archivo:
    archivo.write("Hola, este es un ejemplo de escritura en un archivo.")
```

Aqu√≠, abrimos el archivo en modo escritura y escribimos una cadena de texto en √©l.

#### Ejemplo 3: Agregar Contenido a un Archivo

```python
with open("mi_archivo.txt", "a") as archivo:
    archivo.write("\nEste texto se agrega a continuaci√≥n del contenido existente.")
```

En este ejemplo, abrimos el archivo en modo agregado y agregamos m√°s texto al final.

¬°Fant√°stico! Ahora conoces los conceptos b√°sicos del manejo de archivos en Python. Esto te permitir√° trabajar con datos almacenados en archivos y crear registros de tus programas.

Con esto, completamos nuestra segunda semana de aprendizaje de Python. ¬°Esperando que estos conceptos te ayuden a ampliar tus habilidades y conocimientos en programaci√≥n con Python! En la pr√≥xima semana, continuaremos explorando temas avanzados, como programaci√≥n orientada a objetos y bibliotecas externas.

---


## Programaci√≥n Funcional

La programaci√≥n funcional es un paradigma en el que la programaci√≥n se basa casi en su totalidad en funciones, entendiendo el concepto de funci√≥n seg√∫n su definici√≥n matem√°tica, y no como los simples subprogramas de los lenguajes imperativos. En los lenguajes funcionales puros, un programa consiste exclusivamente en la aplicaci√≥n de distintas funciones a un valor de entrada para obtener un valor de salida. Python, sin ser un lenguaje puramente funcional, incluye varias caracter√≠sticas tomadas de los lenguajes funcionales, como las funciones de orden superior y las funciones lambda (funciones an√≥nimas).

### Beneficios de la Programaci√≥n Funcional

1. **C√≥digo m√°s limpio y expresivo:** Las funciones puras, sin efectos secundarios, son m√°s f√°ciles de razonar y probar.
2. **Facilidad para la concurrencia:** La ausencia de estado mutable simplifica la ejecuci√≥n en paralelo.
3. **Mantenibilidad:** Menos dependencias entre partes del c√≥digo facilita su comprensi√≥n y modificaci√≥n.

### Funciones Puras

Una funci√≥n pura es aquella que, dada la misma entrada, siempre produce la misma salida y no tiene efectos secundarios observables. Por ejemplo:

```python
def suma(a, b):
    return a + b
```



---

### Funciones de Orden Superior



El concepto de funciones de orden superior se refiere al uso de funciones como si de un valor cualquiera se tratara, permitiendo pasar funciones como par√°metros de otras funciones o devolver funciones como valor de retorno. Esto es posible porque, en Python, todo son objetos, incluidas las funciones.

### Ejemplo en Python

```python
def saludar(lang):
    def saludar_es():
        print("Hola")
    
    def saludar_en():
        print("Hi")
    
    def saludar_fr():
        print("Salut")
    
    lang_func = {
        "es": saludar_es,
        "en": saludar_en,
        "fr": saludar_fr
    }
    
    return lang_func[lang]

f = saludar("fr")
f()
```

En este ejemplo, llamamos a la funci√≥n `saludar` con un par√°metro `"fr"`. Dentro de `saludar`, se definen varias funciones (`saludar_es`, `saludar_en` y `saludar_fr`) y se crea un diccionario que asigna cadenas de texto a cada una de estas funciones. El valor de retorno de `saludar` es una de estas funciones, determinada por el valor del par√°metro `lang`.

### Ejemplo con `map`

La funci√≥n `map` aplica una funci√≥n a todos los elementos de una lista o secuencia y devuelve un iterable de tipo `map`.


```python
# Definimos una funci√≥n para calcular el cuadrado de un n√∫mero
def cuadrado(x):
    return x ** 2

numeros = [1, 2, 3, 4, 5]
cuadrados = list(map(cuadrado, numeros))
print(cuadrados)
```

### Explicaci√≥n:
1. Se define la funci√≥n `cuadrado` que toma un argumento `x` y devuelve su cuadrado.
2. Se utiliza `map` con la funci√≥n `cuadrado` y la lista `numeros` para obtener una lista de los cuadrados de los n√∫meros.
3. Se convierte el resultado de `map` en una lista y se imprime.




### Ejemplo con `filter`

Tal como su nombre indica filter significa filtrar, y es una de mis funciones
favoritas, ya que a partir de una lista o iterador y una funci√≥n condicional, es
capaz de devolver una nueva colecci√≥n con los elementos filtrados que cumplan
la condici√≥n. Por ejemplo, supongamos que tenemos una lista de varios n√∫meros
y queremos filtrarla, qued√°ndonos √∫nicamente con los m√∫ltiplos de 5:

```python
def multiple(numero):       # Primero declaramos una funci√≥n condicional
    if numero % 5 == 0:     # Comprobamos si un n√∫mero es m√∫ltiplo de cinco
        return True         # S√≥lo devolvemos True si lo es
    else:
        return False        # Devolvemos False si no lo es

numeros = [2, 5, 10, 23, 50, 33]

filter(multiple, numeros)

# Utilizamos list() para convertir el resultado de filter en una lista y poder imprimirlo
# Casteo de filter a lista
result = list(filter(multiple, numeros))
print(result)
```

Si ejecutamos el filtro obtenemos un objeto de tipo filtro, pero podemos
transformarlo en una lista f√°cilmente haciendo un cast (conversi√≥n):

```python
list(filter(multiple, numeros))
```


```code
[5, 10, 50]
```

### Ejemplo con `reduce`

Reduce es una funci√≥n incorporada de Python 2, que toma como argumento un
conjunto de valores (una lista, una tupla, o cualquier objeto iterable) y lo "reduce"
a un √∫nico valor. C√≥mo se obtiene ese √∫nico valor a partir de la colecci√≥n pasada
como argumento depender√° de la funci√≥n aplicada.

Por ejemplo, el siguiente c√≥digo reduce la lista [1, 2, 3, 4] al n√∫mero 10 aplicando
la funci√≥n add(a, b), que retorna la suma de sus argumentos.

```python
from functools import reduce

def add(a, b):
    return a + b

print(reduce(add, [1, 2, 3, 4]))  # 10
```

La funci√≥n pasada como primer argumento debe tener dos par√°metros. reduce()
se encargar√° de llamarla de forma acumulativa (es decir, preservando el
resultado de llamadas anteriores) de izquierda a derecha. De modo que el c√≥digo
anterior es similar a:

```python
print(add(add(add(1,2), 3), 4))
```

### Ejercicio

Crea una lista de n√∫meros y usa `map` para elevar cada n√∫mero al cuadrado, `filter` para seleccionar solo los n√∫meros impares y `reduce` para obtener el producto de todos los n√∫meros de la lista filtrada.

```python
from functools import reduce

# Funci√≥n para calcular el cuadrado de un n√∫mero
def calcular_cuadrado(x):
    return x ** 2

# Funci√≥n para verificar si un n√∫mero es impar
def es_impar(x):
    return x % 2 != 0

# Funci√≥n para multiplicar dos n√∫meros
def multiplicar(x, y):
    return x * y

numeros = [1, 2, 3, 4, 5]

# Mapeamos los n√∫meros a sus cuadrados
cuadrados = list(map(calcular_cuadrado, numeros))

# Filtramos los n√∫meros cuadrados para obtener los impares
impares = list(filter(es_impar, cuadrados))

# Reducimos la lista de n√∫meros impares para obtener el producto
producto = reduce(multiplicar, impares)

print(producto)
```

---

### Recursi√≥n


La recursi√≥n es una t√©cnica en la que una funci√≥n se llama a s√≠ misma. Es una alternativa a la iteraci√≥n y es com√∫n en la programaci√≥n funcional.

### Ejemplo Cl√°sico: Factorial

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
print(factorial(5))
```

### Ejercicio

Intenta escribir una funci√≥n recursiva para calcular el n-√©simo n√∫mero de Fibonacci. Recuerda que:
- Fibonacci(0) = 0
- Fibonacci(1) = 1
- Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(6))
```

---



### Composici√≥n de Funciones

La composici√≥n de funciones es la aplicaci√≥n sucesiva de m√∫ltiples funciones. En Python, puedes usar la composici√≥n para combinar funciones de manera limpia y legible.

### Ejemplo de Composici√≥n



```python
def doblar(x):
    return x * 2

def incrementar(x):
    return x + 1

def componer(f, g):
    def funcion_compuesta(x):
        return f(g(x))
    return funcion_compuesta

f_compuesta = componer(doblar, incrementar)
print(f_compuesta(3))  # (3 + 1) * 2 = 8
```

### Explicaci√≥n:
1. Se definen las funciones `doblar` y `incrementar` que duplican un n√∫mero y le suman 1, respectivamente.
2. Se define la funci√≥n `componer` que toma dos funciones como argumentos y devuelve una funci√≥n compuesta.
3. En la funci√≥n `componer`, se define una nueva funci√≥n llamada `funcion_compuesta` que aplica primero la funci√≥n `g` y luego la funci√≥n `f`.
4. La funci√≥n `componer` devuelve la funci√≥n `funcion_compuesta`.
5. Se llama a `componer` con las funciones `doblar` e `incrementar`, creando as√≠ la funci√≥n compuesta `f_compuesta`.
6. Se imprime el resultado de `f_compuesta(3)`, que deber√≠a ser `8` seg√∫n la descripci√≥n del comentario.



---



### Funciones Lambda

En Python, una funci√≥n lambda se refiere a una peque√±a funci√≥n an√≥nima. Las llamamos ‚Äúfunciones an√≥nimas‚Äù porque t√©cnicamente carecen de nombre. Al contrario que una funci√≥n normal, no la definimos con la palabra clave est√°ndar `def`. En su lugar, las funciones lambda se definen como una l√≠nea que ejecuta una sola expresi√≥n.

**Sintaxis b√°sica**

Todas las funciones Lambda en Python tienen exactamente la misma sintaxis:


```python
# Escribo p1 y p2 como parametros 1 y 2 de la funcion

lambda p1, p2: expresion
```

### Ejemplo de Funci√≥n Lambda

```python
# Funci√≥n normal
def suma(x, y):
    return x + y

# Funci√≥n lambda
suma_dos = lambda x, y: x + y

# Uso de la funci√≥n lambda
resultado = suma_dos(2, 3)
print(resultado)  # 5
```

### Ejercicio

Crea una funci√≥n lambda que eleve al cubo un n√∫mero y pru√©bala con diferentes valores.

```python
cubo = lambda x: x**3
print(cubo(3))  # 27
print(cubo(4))  # 64
```

---


### Bibliotecas Funcionales

Python tiene varias bibliotecas que facilitan la programaci√≥n funcional, como `functools`, `itertools` y `toolz`.

### Ejemplo con `toolz`

```python
from toolz import curry

@curry
def multiplicar(x, y):
    return x * y

doblar = multiplicar(2)
print(doblar(5))  # 10
```


La funci√≥n `curry` permite crear funciones curried en Python. Una funci√≥n curried es una funci√≥n que toma m√∫ltiples argumentos y los divide en una serie de funciones que toman uno o m√°s argumentos. Esto puede ser √∫til cuando se desea aplicar parcialmente una funci√≥n, es decir, fijar algunos de sus argumentos antes de llamarla.



1. **Importaci√≥n de la funci√≥n `curry` desde la librer√≠a `toolz`:**
   ```python
   from toolz import curry
   ```
   La funci√≥n `curry` se importa desde la librer√≠a `toolz`.

2. **Definici√≥n de la funci√≥n `multiplicar`:**
   ```python
   @curry
   def multiplicar(x, y):
       return x * y
   ```
   Esta funci√≥n toma dos argumentos `x` e `y`, y devuelve su producto. Al decorarla con `@curry`, la funci√≥n `multiplicar` se convierte en una funci√≥n curried.

**Ejemplo de uso:**

Ahora, puedes llamar a la funci√≥n `multiplicar` con uno o m√°s argumentos, o aplicar parcialmente los argumentos.

```python
# Llamada normal
print(multiplicar(3, 4))  # Salida: 12

# Aplicaci√≥n parcial
triplicar = multiplicar(3)
print(triplicar(4))  # Salida: 12
```

En este ejemplo, primero llamamos a `multiplicar` con dos argumentos, `3` y `4`, lo que devuelve `12`. Luego, aplicamos parcialmente la funci√≥n `multiplicar` con el argumento `3`, lo que nos da una nueva funci√≥n llamada `triplicar`, que multiplica su argumento por `3`. Finalmente, llamamos a `triplicar` con el argumento `4`, lo que tambi√©n nos devuelve `12`.


### Ejercicio

Explora la biblioteca `toolz` y prueba algunas de sus funciones en tus propios ejemplos. Comienza con `pipe` y `curry` y ve c√≥mo pueden simplificar tu c√≥digo.



## ¬øQu√© son los M√≥dulos Externos?

Ya hemos visto anteriormente los m√≥dulos externos y vimos que son pedazos de c√≥digo escritos por otros desarrolladores que puedes usar en tus propios programas. Piensa en ellos como hechizos predefinidos que puedes invocar para realizar tareas espec√≠ficas sin tener que escribir todo desde cero. Esto hace que Python sea a√∫n m√°s poderoso y vers√°til.

Para utilizar un m√≥dulo externo, primero debemos importarlo. Python ofrece varias formas de hacerlo, pero aqu√≠ tienes un ejemplo sencillo:

```python
import math

# Ahora, podemos usar funciones matem√°ticas del m√≥dulo math
raiz_cuadrada = math.sqrt(16)
```

esto ya lo habiamos hecho y tambien nuestro propio m√≥dulo personalizado.

**Algunos M√≥dulos Geniales**

Python tiene una vasta biblioteca de m√≥dulos externos para casi cualquier tarea imaginable. Aqu√≠ hay algunos ejemplos emocionantes:

- **`random`**: Para generar n√∫meros aleatorios.
- **`datetime`**: Para trabajar con fechas y tiempos.
- **`requests`**: Para hacer solicitudes HTTP y trabajar con API web.
- **`pandas`**: Para el an√°lisis de datos y manipulaci√≥n de marcos de datos.
- **`matplotlib`**: Para crear visualizaciones y gr√°ficos.

entre otros m√°s.

**Instalando M√≥dulos Externos**

A veces, es posible que necesites m√≥dulos no incluidos en la biblioteca est√°ndar de Python. En ese caso, puedes instalarlos f√°cilmente usando una herramienta llamada `pip`. Por ejemplo:

```bash
pip install nombredelmodulo
```
### ¬øQu√© es pip install?

**pip** es una herramienta que se utiliza para gestionar paquetes y m√≥dulos en Python. Un paquete es como un cofre de tesoros lleno de c√≥digo que otros magos han escrito y compartido. El comando **pip install** es la clave m√°gica que te permite desbloquear estos tesoros y usarlos en tus propios proyectos.

Veamos c√≥mo utilizar este hechizo en Python. Abre tu terminal o l√≠nea de comandos y simplemente ejecuta:

```bash
pip install nombre_del_paquete
```

Por ejemplo, si deseas instalar un paquete popular llamado **requests**, que se utiliza para hacer solicitudes HTTP, simplemente escribes:

```bash
pip install requests
```

¬°Y voil√†! Ahora tienes acceso a todas las habilidades m√°gicas que el paquete *requests* ofrece.

### Administrando Paquetes

Adem√°s de instalar paquetes, pip puede ayudarte a listar, desinstalar o actualizar paquetes. Algunos comandos √∫tiles son:

- `pip list`: Muestra todos los paquetes instalados.
- `pip uninstall nombre_del_paquete`: Elimina un paquete.
- `pip install --upgrade nombre_del_paquete`: Actualiza un paquete a la √∫ltima versi√≥n.




¬°Saludos, j√≥venes programadores de Python! Hoy, nos adentraremos en un emocionante mundo: la Programaci√≥n Orientada a Objetos (POO) en Python.

### ¬øQu√© es la Programaci√≥n Orientada a Objetos?<a name="poo"></a>

La programaci√≥n orientada a objetos, o POO, es un paradigma de programaci√≥n que nos permite abordar problemas complejos pensando en ellos como objetos. Un objeto en Python es una colecci√≥n √∫nica de datos (atributos) y comportamiento (m√©todos).

La Programaci√≥n Orientada a Objetos es como construir con bloques de LEGO. Imagina que tienes diferentes tipos de bloques (objetos) que puedes usar para construir cualquier cosa. En POO, los objetos son como esos bloques, y cada objeto tiene propiedades (atributos) y acciones (m√©todos).

## Programaci√≥n Estructurada Vs. Programaci√≥n Orientada a Objetos

La programaci√≥n estructurada es el enfoque m√°s com√∫n para principiantes, ya que es una forma sencilla de construir programas peque√±os. Se trata de ejecutar un programa Python de forma secuencial. Sin embargo, este enfoque tiene sus desventajas cuando los proyectos crecen y se vuelven m√°s complejos.

Imagina que est√°s en el emocionante mundo de la programaci√≥n, listo para crear un programa para una cafeter√≠a. Tu misi√≥n: hacer que los clientes ingresen su presupuesto y mostrarles qu√© caf√© pueden comprar. Parece una tarea sencilla, ¬øverdad? Sin embargo, la elecci√≥n de tu enfoque de programaci√≥n puede hacer que esta tarea sea un paseo por el parque o una aventura laber√≠ntica. Aqu√≠ es donde entran en juego dos enfoques diferentes: la programaci√≥n estructurada y la programaci√≥n orientada a objetos.

**La Programaci√≥n Estructurada:**

Este enfoque es como la bicicleta de entrenamiento de los programadores principiantes. Comenzamos de manera sencilla, escribiendo l√≠neas de c√≥digo una tras otra. Aqu√≠ tienes un vistazo a c√≥mo podr√≠a verse el c√≥digo de una cafeter√≠a en un mundo estructurado:

```python
small = 2
regular = 5
big = 6

user_budget = input('¬øCu√°l es tu presupuesto? ')

try:
    user_budget = int(user_budget)
except:
    print('Por favor, introduce un n√∫mero')
    exit()

if user_budget > 0:
    if user_budget >= big:
        print('Puedes comprar el caf√© grande')
        if user_budget == big:
            print('Es exacto')
        else:
            print('Tu cambio es', user_budget - big)
    elif user_budget == regular:
        print('Puedes comprar el caf√© regular')
        print('Es exacto')
    elif user_budget >= small:
        print('Puedes comprar el caf√© peque√±o')
        if user_budget == small:
            print('Es exacto')
        else:
            print('Tu cambio es', user_budget - small)
```

¬°Funciona! Pero, oh, tiene mucho condicional anidado y l√≥gica repetida. Modificarlo en el futuro podr√≠a ser un dolor de cabeza.

**La Programaci√≥n Orientada a Objetos (POO):**

Ahora, piensa en la POO como tu m√°quina de caf√© de alta gama. Es elegante, eficiente y personalizable. En lugar de escribir l√≠neas y l√≠neas de c√≥digo, puedes organizar todo en una "caja" ordenada. Mira c√≥mo funciona:

```python
class Coffee:
    def __init__(self, name, price):
        self.name = name
        self.price = float(price)

    def check_budget(self, budget):
        if not isinstance(budget, (int, float)):
            print('Ingresa un n√∫mero o decimal')
            exit()
        if budget < 0:
            print('Lo siento, no tienes dinero')
            exit()

    def get_change(self, budget):
        return budget - self.price

    def sell(self, budget):
        self.check_budget(budget)
        if budget >= self.price:
            print(f'Puedes comprar el caf√© {self.name}')
            if budget == self.price:
                print('Es exacto')
            else:
                print(f'Aqu√≠ tienes tu cambio: {self.get_change(budget)}$')
            exit('Gracias por tu compra')            
```

Este c√≥digo luce diferente, ¬øverdad? Hemos creado una "clase" llamada "Coffee" que contiene toda la informaci√≥n y l√≥gica relacionada con el caf√©. La belleza de esto es que podemos crear m√∫ltiples tipos de caf√© sin l√≠o.

Entonces, ¬øc√≥mo lo usamos? Simple, creamos objetos de caf√© y los vendemos:

```python
small = Coffee('Peque√±o', 2)
regular = Coffee('Regular', 5)
big = Coffee('Grande', 6)

try:
    user_budget = float(input('¬øCu√°l es tu presupuesto? '))
except ValueError:
    exit('Por favor, introduce un n√∫mero')

for coffee in [big, regular, small]:
    coffee.sell(user_budget)
```

Ambos enfoques nos llevan al mismo resultado, pero la POO es como tener un equipo de baristas expertos que trabajan juntos de manera organizada y elegante. Es especialmente √∫til cuando tu proyecto crece y necesitas m√°s funcionalidades. ¬°As√≠ que levanta tu taza de caf√© y da la bienvenida a la programaci√≥n orientada a objetos en tu vida!

### Todo en Python es un Objeto

Una caracter√≠stica destacada de Python es que todo es un objeto. Desde n√∫meros, cadenas y listas hasta funciones y clases, todos ellos son objetos. Esto significa que todos los objetos tienen atributos y m√©todos que puedes utilizar.

Para acceder a los atributos y m√©todos de un objeto, utilizamos la notaci√≥n de puntos. Por ejemplo, puedes convertir una cadena en may√∫sculas con el m√©todo `upper()` o comprobar su tipo con `type()`.

```
my_string = "Hola, soy una cadena"
print(my_string.upper())  # Imprime la cadena en may√∫sculas
print(type(my_string))  #

 Imprime el tipo de objeto
```

Si no qued√≥ claro puedes ver este video explicado con minecraft:
[![POO](./src/img/poo.jpg)](https://youtu.be/I848HdWjLMo?si=NFPgYRX0TzdrO_TC)

## ¬øQu√© Son las Clases?<a name="clases"></a>

En t√©rminos sencillos, una clase es como un plano o plantilla para crear objetos. Un objeto es una instancia de una clase, y se comporta seg√∫n las reglas definidas por esa clase. Puedes pensar en las clases como si fueran moldes y los objetos como las piezas de un rompecabezas.

## Creando una Clase en Python

Para definir una clase en Python, utilizamos la palabra clave `class`, seguida del nombre de la clase (generalmente en CamelCase). Aqu√≠ tienes un ejemplo simple:

```python
class Perro:
    pass
```

Hasta ahora, nuestra clase de perro est√° vac√≠a, ¬°como si fuera un perro sin caracter√≠sticas ni trucos! Pero no te preocupes, ¬°le daremos vida a este perro en un momento!

## Creando un Objeto (Instancia)<a name="objetos"></a>

Una vez que has definido una clase, puedes crear objetos (instancias) de esa clase. Para hacerlo, simplemente llama a la clase como si fuera una funci√≥n. Por ejemplo:

```python
mi_perro = Perro()  # Creamos una instancia de la clase Perro
```

¬°Ahora tienes un perro virtual, mi_perro, que es un objeto de la clase Perro!

## Atributos de Clase

Los atributos son como las caracter√≠sticas o datos que pertenecen a una clase. Pueden variar de un objeto a otro. Aqu√≠ hay un ejemplo de c√≥mo a√±adir atributos a nuestra clase Perro:

```python
class Perro:
    def __init__(self, nombre, raza):
        self.nombre = nombre
        self.raza = raza
```

En el ejemplo anterior, hemos creado un m√©todo especial llamado `__init__`, que se llama autom√°ticamente cuando se crea un nuevo objeto. Este m√©todo se utiliza para inicializar los atributos del objeto. `self` hace referencia al objeto actual (en este caso, al perro que estamos creando).

Ahora puedes crear un perro con nombre y raza:

```python
mi_perro = Perro("Fido", "Labrador")
print(mi_perro.nombre)  # Imprime "Fido"
print(mi_perro.raza)  # Imprime "Labrador"
```

## M√©todos de Clase

Los m√©todos son como las habilidades o funciones que un objeto puede realizar. Pueden interactuar con los atributos del objeto y realizar diversas tareas. Aqu√≠ tienes un ejemplo de c√≥mo a√±adir un m√©todo a nuestra clase Perro:

```python
class Perro:
    def __init__(self, nombre, raza):
        self.nombre = nombre
        self.raza = raza
    
    def ladrar(self):
        print(f"{self.nombre} est√° ladrando: ¬°Guau, guau!")
```

Ahora, tu perro virtual puede ladrar:

```python
mi_perro = Perro("Fido", "Labrador")
mi_perro.ladrar()  # Imprime "Fido est√° ladrando: ¬°Guau, guau!"
```

Las clases en Python son una de las herramientas m√°s vers√°tiles y poderosas que tienes a tu disposici√≥n. Puedes crear objetos con atributos y m√©todos personalizados para representar conceptos y entidades del mundo real en tu c√≥digo.

### M√©todo constructor<a name="constructor"></a>

¬øAlguna vez has deseado crear objetos con caracter√≠sticas √∫nicas y bien definidas en Python? El "M√©todo Constructor" es la respuesta a ese deseo. Este m√©todo se llama autom√°ticamente cuando creas un nuevo objeto de una clase, y su funci√≥n es inicializar los atributos de ese objeto. Imagina que est√°s fabricando robots en tu propia f√°brica de Python. Cada robot tendr√° su propio nombre, color y nivel de bater√≠a, ¬°y el m√©todo constructor es la clave para lograrlo!

Veamos c√≥mo funciona:

```python
class Robot:
    def __init__(self, nombre, color, bateria):
        self.nombre = nombre
        self.color = color
        self.bateria = bateria

# Crear un robot llamado R2-D2
robot1 = Robot("R2-D2", "Azul y blanco", 100)

# Crear otro robot llamado Wall-E
robot2 = Robot("Wall-E", "Marr√≥n", 80)
```

En este ejemplo, hemos definido una clase llamada `Robot`. El m√©todo `__init__` toma cuatro par√°metros: `self`, `nombre`, `color`, y `bateria`. El par√°metro `self` hace referencia al objeto que est√° siendo creado. Luego, asignamos los valores de `nombre`, `color` y `bateria` a los atributos del robot utilizando `self`.

Ahora que hemos dado vida a nuestros robots, podemos personalizarlos seg√∫n nuestras necesidades. Puedes acceder a los atributos de un objeto y modificarlos:

```python
# Acceder a los atributos del robot R2-D2
print(robot1.nombre)  # Imprime "R2-D2"
print(robot1.color)   # Imprime "Azul y blanco"
print(robot1.bateria) # Imprime 100

# Modificar la bater√≠a de Wall-E
robot2.bateria = 90
print(robot2.bateria) # Imprime 90
```

El m√©todo constructor `__init__` se encarg√≥ de crear nuestros robots con sus atributos iniciales, pero luego somos libres de personalizarlos como queramos.

#### **Por Qu√© el M√©todo Constructor es Importante**

El m√©todo constructor es fundamental en la programaci√≥n orientada a objetos. Permite la creaci√≥n de objetos con atributos espec√≠ficos, lo que los hace √∫nicos y listos para realizar tareas particulares. Imagina que cada objeto es un personaje en tu propio mundo de programaci√≥n, ¬°y el m√©todo constructor es lo que les da vida y personalidad!

A medida que avances en tu viaje por Python, te dar√°s cuenta de que el m√©todo constructor es solo el comienzo. Puedes agregar otros m√©todos y atributos a tus clases para hacer que tus objetos hagan cosas sorprendentes.

## Descifrando el Misterio de "self"

En el mundo de la programaci√≥n orientada a objetos, los objetos son como personajes en una obra de teatro, y cada uno tiene su propia identidad y habilidades. El "self" es la forma en que Python le permite a un objeto referirse a s√≠ mismo. Es como si cada actor en una obra de teatro tuviera un espejo m√°gico que refleja qui√©nes son y qu√© pueden hacer.

Para entender mejor, echemos un vistazo a un ejemplo:

```python
class Robot:
    def __init__(self, nombre, bateria):
        self.nombre = nombre
        self.bateria = bateria

    def saludar(self):
        return f"Hola, soy {self.nombre}."

# Crear un robot llamado R2-D2
robot1 = Robot("R2-D2", 100)

# Crear otro robot llamado Wall-E
robot2 = Robot("Wall-E", 80)

# Hacer que los robots saluden
saludo_robot1 = robot1.saludar()
saludo_robot2 = robot2.saludar()

print(saludo_robot1)  # Imprime "Hola, soy R2-D2."
print(saludo_robot2)  # Imprime "Hola, soy Wall-E."
```

En este ejemplo, hemos creado una clase llamada `Robot`. Dentro de la clase, el m√©todo `__init__` inicializa los atributos del robot. El m√©todo `saludar` utiliza "self" para acceder al nombre del robot. El "self" permite que cada robot hable en su propio nombre.

## ¬øPor Qu√© es Importante "self"?

El "self" es fundamental en la programaci√≥n orientada a objetos. Sin √©l, los objetos no podr√≠an saber qui√©nes son ni interactuar con su propio conjunto de datos. Es lo que permite que un objeto acceda a sus atributos y m√©todos de una manera espec√≠fica.

Piensa en el "self" como el coraz√≥n de un objeto. Es lo que hace que un objeto sea √∫nico y le permite actuar de acuerdo con su propia naturaleza. Cada objeto es como un actor en su propia historia, y el "self" es el guion que le dice qu√© hacer.


## M√©todos en Python: Personaliza y Mejora tus Clases


Cuando creas una clase en Python, esta hereda autom√°ticamente de la clase base `object`, lo que significa que tiene acceso a ciertos m√©todos por defecto que puedes sobrescribir para ajustar el comportamiento de tus objetos. A continuaci√≥n, exploraremos algunos de estos m√©todos y c√≥mo se pueden utilizar para mejorar la representaci√≥n y funcionalidad de tus clases.

### Principales M√©todos por Defecto

1. **`__init__(self)` - Constructor de la Clase:**
   
   El m√©todo `__init__` es el constructor de la clase y se llama autom√°ticamente cuando se crea una nueva instancia de la clase. Su principal funci√≥n es inicializar los atributos del objeto.

   ```python
   class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age
   ```

2. **`__str__(self)` - Representaci√≥n en Cadena del Objeto:**
   
   El m√©todo `__str__` devuelve una representaci√≥n en cadena del objeto y se utiliza principalmente con `print()` y `str()`. Este m√©todo es ideal para proporcionar una descripci√≥n legible y amigable del objeto.

3. **`__repr__(self)` - Representaci√≥n Oficial del Objeto:**
   
   El m√©todo `__repr__` devuelve una representaci√≥n ‚Äúoficial‚Äù del objeto y se utiliza principalmente con `repr()`. Est√° dise√±ado para devolver una cadena que represente al objeto de manera que se pueda recrear, lo cual es muy √∫til para la depuraci√≥n.

### Ejemplo: Sobrescribiendo los M√©todos `__str__` y `__repr__`

Veamos c√≥mo se pueden sobrescribir estos m√©todos en una clase `Person`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}, {self.age} a√±os"

    def __repr__(self):
        return f"Person(name={self.name}, age={self.age})"

# Crear instancias de Person
person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

# Uso de __str__
print(person1)  # Output: Alice, 30 a√±os

# Uso de __repr__
print(repr(person1))  # Output: Person(name=Alice, age=30)
```

**Explicaci√≥n del C√≥digo:**

- El m√©todo `__str__` devuelve una representaci√≥n amigable y f√°cil de leer del objeto, que es √∫til para la salida en pantalla o para mostrar informaci√≥n al usuario.
  
- El m√©todo `__repr__` proporciona una representaci√≥n m√°s t√©cnica y detallada del objeto, ideal para la depuraci√≥n. Este m√©todo debe devolver una cadena que, si se evaluara, recrear√≠a el objeto.

Estos m√©todos no solo hacen que la representaci√≥n de los objetos sea m√°s intuitiva y legible, sino que tambi√©n facilitan la depuraci√≥n y el manejo de los objetos en el c√≥digo.

### Otros M√©todos Especiales √ötiles

Adem√°s de `__str__` y `__repr__`, hay otros m√©todos especiales que puedes sobrescribir para personalizar tus clases:

- **`__eq__(self, other)` - Comparaci√≥n de Igualdad:**
  
  Define c√≥mo se comparan dos objetos para la igualdad. Por ejemplo, podr√≠as querer comparar objetos de la clase `Person` bas√°ndote en sus nombres y edades.

  ```python
  def __eq__(self, other):
      return self.name == other.name and self.age == other.age
  ```

- **`__lt__(self, other)` - Comparaci√≥n de Menor Que:**
  
  Permite definir el comportamiento del operador `<`. Es √∫til si necesitas ordenar objetos de tu clase.

  ```python
  def __lt__(self, other):
      return self.age < other.age
  ```

### Importancia de los M√©todos Especiales

Comprender y sobrescribir estos m√©todos especiales es esencial para escribir c√≥digo Python que sea limpio, eficiente y f√°cil de mantener. Estos m√©todos permiten:

- **Extender Funcionalidades:** Puedes extender funcionalidades heredadas de clases padres sin necesidad de duplicar c√≥digo.
  
- **Inicializaci√≥n Correcta:** El uso adecuado de constructores como `__init__` asegura que todos los atributos de un objeto se inicialicen correctamente, evitando errores futuros.

- **Personalizar Representaciones:** M√©todos como `__str__` y `__repr__` permiten personalizar c√≥mo se muestran los objetos, lo que facilita la interacci√≥n con ellos y la depuraci√≥n del c√≥digo.

- **Comparar y Ordenar Objetos:** M√©todos como `__eq__`, `__lt__`, etc., son esenciales para definir reglas de comparaci√≥n entre objetos, lo cual es muy √∫til en estructuras de datos y algoritmos.




## Desentra√±ando el Misterio de la Herencia

La herencia es un concepto clave en la programaci√≥n orientada a objetos (POO) y juega un papel vital en la creaci√≥n de programas s√≥lidos y organizados. En esencia, la herencia te permite **heredar** propiedades y comportamientos de una clase existente y construir una nueva clase sobre esa base.

Pensemos en la herencia de la siguiente manera: Imagina que eres un artista y tienes una paleta de colores con mezclas √∫nicas. Ahora, quieres crear una nueva pintura, ¬øcomenzar√≠as desde cero o usar√≠as tus colores ya existentes como punto de partida? La herencia te permite aprovechar esas mezclas existentes para crear algo nuevo y emocionante.

## La Magia de la Herencia en Python

En Python, la herencia es sencilla y poderosa. Aqu√≠ tienes un ejemplo para ilustrar c√≥mo funciona:

```python
class CriaturaMagica:
    def __init__(self, nombre, poder):
        self.nombre = nombre
        self.poder = poder

    def lanzar_hechizo(self):
        print(f"{self.nombre} lanza un hechizo.")

class Dragon(CriaturaMagica):
    def escupir_fuego(self):
        print(f"{self.nombre} escupe fuego y causa estragos.")
```

En este c√≥digo, hemos definido dos clases. La clase `Dragon` hereda de la clase `CriaturaMagica`. Esto significa que un drag√≥n no solo tiene sus propias caracter√≠sticas, como la capacidad de escupir fuego, sino que tambi√©n hereda todas las caracter√≠sticas de una criatura m√°gica, como lanzar hechizos.

## La Magia Contin√∫a

Ahora que hemos aprendido sobre la herencia, te preguntar√°s por qu√© es tan importante. La herencia es una herramienta m√°gica que te permite:

1. **Reutilizar c√≥digo**: No necesitas empezar desde cero; puedes aprovechar las clases existentes.
2. **Organizar tu c√≥digo**: Crea una estructura jer√°rquica que hace que tu programa sea m√°s f√°cil de entender.
3. **Extender funcionalidad**: Agrega nuevas caracter√≠sticas a las clases base sin afectar su funcionamiento original.
4. **Mantiene tu c√≥digo limpio y legible**: Al reducir la duplicaci√≥n y mejorar la organizaci√≥n.

La herencia es una de las piedras angulares de la POO en Python. Te permite construir programas m√°s flexibles y mantenibles. Ahora que has desbloqueado el poder de la herencia, te animo a explorar y experimentar por ti mismo. ¬°Crea tus propias clases y observa c√≥mo la herencia facilita la construcci√≥n de programas asombrosos!

Si no qued√≥ claro puedes ver este video explicado con minecraft:
[![Herencia](/src/img/herencia.JPG)](https://youtu.be/yh8bTKqCOtU?si=O4cIewNxbWpnHMbi)


## Encapsulaci√≥n<a name="encapsulacion"></a>

La encapsulaci√≥n se asemeja a un cofre fuerte que protege y oculta los detalles internos de un objeto. Imagina que eres un mago y tienes un libro de hechizos. ¬øPermitir√≠as que cualquiera vea tus hechizos m√°s poderosos? Por supuesto que no. De manera similar, la encapsulaci√≥n se trata de **ocultar los detalles internos** de un objeto y **exponer solo lo que es necesario**.

## C√≥mo Funciona la Encapsulaci√≥n en Python

Python hace que la encapsulaci√≥n sea sencilla mediante el uso de **atributos privados** y **m√©todos privados**. Esto significa que algunos componentes de una clase no son accesibles desde fuera de la clase.

```python
class SuperHeroe:
    def __init__(self, nombre, identidad_secreta):
        self.nombre = nombre          # Atributo p√∫blico
        self.__identidad = identidad_secreta  # Atributo privado

    def revelar_identidad(self):
        return self.__identidad
```

En este ejemplo, `nombre` es un atributo p√∫blico que puede ser accedido desde fuera de la clase. Sin embargo, `__identidad` es un atributo privado que solo puede ser accedido desde dentro de la clase. Esto protege la identidad secreta del superh√©roe.

Si no qued√≥ claro puedes ver este video explicado con minecraft:
[![Encapsulamiento](./src/img/encapsulamiento.JPG)](https://youtu.be/8aQSD36paWU?si=6-ydXxb2cT3B_BsM)





## ¬øQu√© es el Polimorfismo?

El t√©rmino "polimorfismo" proviene del griego y significa "muchas formas". En programaci√≥n, el polimorfismo se refiere a la capacidad de diferentes objetos para responder a la misma llamada de m√©todo de manera espec√≠fica para cada uno. En otras palabras, varios objetos pueden realizar la misma acci√≥n, pero de una manera que es relevante para ellos.

## Un Ejemplo Sencillo

Imagina una familia de mascotas con perros, gatos y p√°jaros. Todos ellos pueden hacer un sonido, pero cada uno lo hace de una manera √∫nica:

```python
class Mascota:
    def hacer_sonido(self):
        pass

class Perro(Mascota):
    def hacer_sonido(self):
        return "¬°Guau!"

class Gato(Mascota):
    def hacer_sonido(self):
        return "¬°Miau!"

class Pajaro(Mascota):
    def hacer_sonido(self):
        return "¬°P√≠o!"
```

En este ejemplo, hemos creado una jerarqu√≠a de clases de mascotas con un m√©todo `hacer_sonido`. Cada tipo de mascota (perro, gato, p√°jaro) implementa este m√©todo de manera espec√≠fica para s√≠ mismo.

Si no qued√≥ claro puedes ver este video explicado con minecraft:
[![Polimorfismo](/src/img/polimorfismo.JPG)](https://youtu.be/bblFTvuk4pY?si=KYIQrYpdIC68Ub9e)



## Explorando `super()` en Python: Simplificando la Herencia en Clases


Python es conocido por su simplicidad y elegancia, especialmente cuando se trata de herencia en programaci√≥n orientada a objetos. Uno de los mecanismos m√°s poderosos y √∫tiles en este contexto es la funci√≥n `super()`. Esta funci√≥n permite a las clases hijas llamar a m√©todos y acceder a propiedades de sus clases padres sin complicaciones, mejorando la reutilizaci√≥n del c√≥digo y la mantenibilidad. En este blog, exploraremos c√≥mo `super()` funciona, cu√°ndo usarlo, y veremos ejemplos pr√°cticos para entender su utilidad.

#### ¬øQu√© es `super()`?

`super()` es una funci√≥n incorporada en Python que se utiliza para llamar a m√©todos o inicializadores de la clase padre desde una clase hija. Es particularmente √∫til en la herencia m√∫ltiple y permite que el c√≥digo sea m√°s legible y flexible, reduciendo la necesidad de llamar expl√≠citamente a la clase padre por su nombre. Adem√°s, ayuda a mantener una cadena de llamada limpia y organizada, especialmente en escenarios complejos de herencia.

#### Ejemplo 1: Usando `super()` en una Clase Hija

Consideremos un ejemplo b√°sico con dos clases: `Person` y `Student`. La clase `Person` es la clase padre, mientras que `Student` es la clase hija que hereda de `Person`. Utilizamos `super()` para llamar al inicializador de la clase `Person` desde la clase `Student`.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print("Hello! I am a person.")

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.student_id = student_id

    def greet(self):
        super().greet()  # Llama al m√©todo greet() de la clase padre
        print(f"Hello, my student ID is {self.student_id}")

student = Student("Ana", 20, "S123")
student.greet()
```

**Salida:**
```
Hello! I am a person.
Hello, my student ID is S123
```

En este ejemplo, `super()` se utiliza en dos lugares clave:

1. **Inicializaci√≥n del Constructor:** En `Student`, usamos `super().__init__(name, age)` para inicializar los atributos `name` y `age` definidos en `Person`. Esto evita repetir el c√≥digo de inicializaci√≥n que ya est√° en la clase padre.
  
2. **M√©todo `greet()`:** En el m√©todo `greet()` de `Student`, `super().greet()` llama al m√©todo `greet()` de `Person` antes de a√±adir un mensaje adicional espec√≠fico de `Student`.

#### Ejemplo 2: Herencia M√∫ltiple con `super()`

`super()` se vuelve a√∫n m√°s poderoso cuando se trabaja con herencia m√∫ltiple. En el siguiente ejemplo, tenemos tres niveles de herencia: `LivingBeing`, `Person`, y `Student`.

```python
class LivingBeing:
    def __init__(self, name):
        self.name = name

class Person(LivingBeing):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.student_id = student_id

    def introduce(self):
        print(f"Hi, I'm {self.name}, {self.age} years old, and my student ID is {self.student_id}")

student = Student("Carlos", 21, "S54321")
student.introduce()
```

**Salida:**
```
Hi, I'm Carlos, 21 years old, and my student ID is S54321
```

En este ejemplo, `super()` nos permite hacer lo siguiente:

- En `Person`, `super().__init__(name)` llama al constructor de `LivingBeing`, inicializando `name`.
- En `Student`, `super().__init__(name, age)` llama al constructor de `Person`, inicializando tanto `name` como `age`.

Esto muestra c√≥mo `super()` facilita el encadenamiento de inicializadores en m√∫ltiples niveles de herencia.

#### ¬øPor Qu√© Usar `super()`?

- **Simplicidad y Legibilidad:** `super()` reduce la necesidad de referirse expl√≠citamente a la clase padre, haciendo que el c√≥digo sea m√°s limpio y f√°cil de entender.
  
- **Compatibilidad con M√∫ltiples Herencias:** En herencias m√∫ltiples, `super()` sigue el orden de resoluci√≥n de m√©todo (MRO) de Python, asegurando que los m√©todos se llamen en el orden correcto.

- **Evita Repeticiones:** Permite reutilizar el c√≥digo de la clase padre sin copiar y pegar, lo cual es m√°s eficiente y reduce el riesgo de errores.



`super()` es una herramienta esencial para cualquier programador Python que trabaje con clases y herencia. Simplifica la llamada a m√©todos y constructores de la clase padre, promoviendo la reutilizaci√≥n del c√≥digo y facilitando la gesti√≥n de herencias complejas. Ya sea que est√©s trabajando con jerarqu√≠as simples o m√∫ltiples niveles de herencia, dominar el uso de `super()` te permitir√° escribir c√≥digo m√°s limpio, eficiente y mantenible.

Explorar y entender `super()` es un paso fundamental para aprovechar al m√°ximo las capacidades de la programaci√≥n orientada a objetos en Python. ¬°Empieza a utilizar `super()` en tus proyectos y experimenta c√≥mo puede transformar la forma en que manejas la herencia en tus clases!



## M√©todos de los Objetos: cadenas

Una cadena en Python es una secuencia inmutable de caracteres. Esto significa que una vez que una cadena se crea, no se puede modificar. Puedes definir una cadena simplemente encerrando un texto entre comillas simples (`'...'`) o dobles (`"..."`). Por ejemplo:

```python
mi_cadena = "Hola, mundo"
```

## M√©todos Comunes de las Cadenas

### 1. `count(sub[, start[, end]])`

Este m√©todo devuelve el n√∫mero de veces que se encuentra la subcadena `sub` en la cadena. Los par√°metros opcionales `start` y `end` definen una subcadena en la que buscar.

```python
texto = "Hola, mundo. Hola, Python."
print(texto.count("Hola"))  # 2
print(texto.count("Hola", 0, 10))  # 1
print(texto.count("Hola", 0, 17))  # 2 porque el nuemro de caracteres abarcan los 2 textos hola
```

### 2. `find(sub[, start[, end]])`

Devuelve la posici√≥n en la que se encuentra por primera vez la subcadena `sub` en la cadena, o `-1` si no se encuentra. Tambi√©n puede recibir los par√°metros opcionales `start` y `end` para definir una subcadena en la que buscar.

```python
frase = "Hola, mundo"
print(frase.find("mundo"))  # 6
print(frase.find("Python")) # -1
```

### 3. `join(sequence)`

Devuelve una cadena resultante de concatenar las cadenas de la secuencia `sequence`, separadas por la cadena sobre la que se llama el m√©todo.

```python
palabras = ["Hola", "Mundo", "Python"]
separador = " "
print(separador.join(palabras))  # "Hola Mundo Python"
```

### 4. `partition(sep)`

Busca el separador `sep` en la cadena y devuelve una tupla con la subcadena hasta dicho separador, el separador en s√≠, y la subcadena desde el separador hasta el final de la cadena. Si no se encuentra el separador, la tupla contendr√° la cadena en s√≠ y dos cadenas vac√≠as.

```python
frase = "Hola, mundo"
print(frase.partition(","))  # ('Hola', ',', ' mundo')
print(frase.partition("Python"))  # ('Hola, mundo', '', '')
```

### 5. `replace(old, new[, count])`

Devuelve una cadena en la que se han reemplazado todas las ocurrencias de la cadena `old` por la cadena `new`. Si se especifica el par√°metro `count`, este indica el n√∫mero m√°ximo de ocurrencias a reemplazar.

```python
texto = "Hola, mundo. Hola, Python."
nuevo_texto = texto.replace("Hola", "Hi", 1)
print(nuevo_texto)  # "Hi, mundo. Hola, Python."
```

### 6. `split([sep[, maxsplit]])`

Devuelve una lista conteniendo las subcadenas en las que se divide nuestra cadena al dividirlas por el delimitador `sep`. En el caso de que no se especifique `sep`, se usan espacios. Si se especifica `maxsplit`, este indica el n√∫mero m√°ximo de particiones a realizar.

```python
frase = "Hola, mundo, c√≥mo est√°s"
print(frase.split(", "))  # ['Hola', 'mundo', 'c√≥mo', 'est√°s']
print(frase.split(", ", 1))  # ['Hola', 'mundo, c√≥mo est√°s']
```

### 7. `upper()` y `lower()`

Estos m√©todos son perfectos para convertir todo el texto de una cadena a may√∫sculas o min√∫sculas respectivamente.

```python
texto = "Hola, Mundo"
print(texto.upper())  # "HOLA, MUNDO"
print(texto.lower())  # "hola, mundo"
```

### 8. `strip()`, `lstrip()`, y `rstrip()`

A menudo, es necesario eliminar espacios en blanco o caracteres espec√≠ficos del principio o el final de una cadena. Aqu√≠ es donde estos m√©todos resultan √∫tiles:

```python
mensaje = "   Hola, Mundo!   "
print(mensaje.strip())   # "Hola, Mundo!" all
print(mensaje.lstrip())  # "Hola, Mundo!   " left
print(mensaje.rstrip())  # "   Hola, Mundo!" right
```

## Ejemplos aplicativos

### Contador de Palabras

Vamos a crear una funci√≥n que cuente cu√°ntas veces aparece cada palabra en una cadena. Esto puede ser muy √∫til para analizar textos.

```python
def contador_palabras(texto):
    palabras = texto.lower().split()
    conteo = {}
    for palabra in palabras:
        if palabra in conteo:
            conteo[palabra] += 1
        else:
            conteo[palabra] = 1
    return conteo

texto = "Hola hola hola Mundo mundo"
print(contador_palabras(texto))
# {'hola': 3, 'mundo': 2}
```

### Generador de Acr√≥nimos

Otra aplicaci√≥n interesante es un generador de acr√≥nimos a partir de una frase.

```python
def generar_acronimo(frase):
    palabras = frase.split()
    acronimo = "".join([palabra[0].upper() for palabra in palabras])
    return acronimo

frase = "Asociaci√≥n de Padres de Familia"
print(generar_acronimo(frase))  # "ADPDF"

frase = "Dr. Doofenshmirtz Malvados y Asociados"
print(generar_acronimo(frase))  # "DDMYA"
```

### Inversor de Palabras

Finalmente, creemos una funci√≥n que invierta cada palabra de una frase, manteniendo el orden de las palabras.

```python
def invertir_palabras(frase):
    palabras = frase.split()
    palabras_invertidas = [palabra[::-1] for palabra in palabras]
    return " ".join(palabras_invertidas)

frase = "Hola Mundo"
print(invertir_palabras(frase))  # "aloH odnuM"
```


## M√©todos Comunes de las Listas

### 1. `append(object)`

Este m√©todo a√±ade un objeto al final de la lista.

```python
mi_lista = [1, 2, 3]
mi_lista.append(4)
print(mi_lista)  # [1, 2, 3, 4]
```

### 2. `count(value)`

Devuelve el n√∫mero de veces que se encuentra el valor `value` en la lista.

```python
mi_lista = [1, 2, 3, 2, 2, 4]
print(mi_lista.count(2))  # 3
```

### 3. `extend(iterable)`

A√±ade los elementos del iterable a la lista.

```python
mi_lista = [1, 2, 3]
mi_lista.extend([4, 5, 6])
print(mi_lista)  # [1, 2, 3, 4, 5, 6]
```

### 4. `index(value[, start[, stop]])`

Devuelve la posici√≥n en la que se encuentra la primera ocurrencia del valor `value`. Si se especifican, `start` y `stop` definen las posiciones de inicio y fin de una sublista en la que buscar.

```python
mi_lista = [1, 2, 3, 2, 4]
print(mi_lista.index(2))  # 1
print(mi_lista.index(2, 2))  # 3
```

### 5. `insert(index, object)`

Inserta el objeto en la posici√≥n `index`.

```python
mi_lista = [1, 2, 3]
mi_lista.insert(1, 'a')
print(mi_lista)  # [1, 'a', 2, 3]
```

### 6. `pop([index])`

Devuelve el valor en la posici√≥n `index` y lo elimina de la lista. Si no se especifica la posici√≥n, se utiliza el √∫ltimo elemento de la lista.

```python
mi_lista = [1, 2, 3]
print(mi_lista.pop())  # 3
print(mi_lista)  # [1, 2]
print(mi_lista.pop(0))  # 1
print(mi_lista)  # [2]
```

### 7. `remove(value)`

Elimina la primera ocurrencia de `value` en la lista.

```python
mi_lista = [1, 2, 3, 2]
mi_lista.remove(2)
print(mi_lista)  # [1, 3, 2]
```

### 8. `reverse()`

Invierte la lista. Esta funci√≥n trabaja sobre la propia lista desde la que se invoca el m√©todo, no sobre una copia.

```python
mi_lista = [1, 2, 3]
mi_lista.reverse()
print(mi_lista)  # [3, 2, 1]
```

### 9. `sort(cmp=None, key=None, reverse=False)`

Ordena la lista. Si se especifica `cmp`, este debe ser una funci√≥n que tome como par√°metros dos valores `x` e `y` de la lista y devuelva `-1` si `x` es menor que `y`, `0` si son iguales y `1` si `x` es mayor que `y`. El par√°metro `reverse` es un booleano que indica si se debe ordenar la lista de forma inversa.

```python
mi_lista = [3, 1, 2]
mi_lista.sort()
print(mi_lista)  # [1, 2, 3]
mi_lista.sort(reverse=True)
print(mi_lista)  # [3, 2, 1]
```

## Ejemplos aplicativos


### Combinando M√©todos de Cadenas y Listas

Ahora que hemos visto algunos de los m√©todos m√°s √∫tiles para las cadenas y las listas, combin√©moslos para resolver algunos problemas interesantes.

### Contador de Palabras Mejorado

Vamos a mejorar nuestra funci√≥n de contador de palabras para que ignore la puntuaci√≥n.

```python
import string

def contador_palabras_mejorado(texto):
    # Eliminar la puntuaci√≥n del texto
    texto = texto.translate(str.maketrans("", "", string.punctuation))
    palabras = texto.lower().split()
    conteo = {}
    for palabra in palabras:
        if palabra in conteo:
            conteo[palabra] += 1
        else:
            conteo[palabra] = 1
    return conteo

texto = "Hola, hola. ¬°Hola, mundo! Mundo, mundo."
print(contador_palabras_mejorado(texto))
# {'hola': 3, 'mundo': 3}
```

### Generador de Acr√≥nimos con Filtrado

Vamos a mejorar nuestra funci√≥n de generador de acr√≥nimos para que ignore palabras comunes como "de", "y", "la", etc.

```python
def generar_acronimo_mejorado(frase):
    palabras_comunes = {"de", "y", "la", "el", "en"}
    palabras = frase.split()
    acronimo = "".join([palabra[0].upper() for palabra in palabras if palabra.lower() not in palabras_comunes])
    return acronimo

frase = "Asociaci√≥n de Padres y Madres en la Escuela"
print(generar_acronimo_mejorado(frase))  # "APME"
```

### Inversor de Palabras Mejorado

Vamos a mejorar nuestra funci√≥n de invertir palabras para que tambi√©n invierta el orden de las palabras en la frase.

```python
def invertir_frase_completa(frase):
    palabras = frase.split()
    palabras_invertidas = [palabra[::-1] for palabra in palabras]
    palabras_invertidas.reverse()
    return " ".join(palabras_invertidas)

frase = "Hola Mundo"
print(invertir_frase_completa(frase))  # "odnuM aloH"
```



## M√©todos Comunes de los Diccionarios

### 1. `get(k[, d])`

Este m√©todo busca el valor de la clave `k` en el diccionario. Es equivalente a utilizar `D[k]`, pero permite indicar un valor por defecto `d` que se devolver√° si la clave no se encuentra. Si la clave no existe y no se especifica un valor por defecto, se devolver√° `None`.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print(mi_dict.get('b'))  # 2
print(mi_dict.get('d', 0))  # 0
print(mi_dict.get('d'))  # None
```

### 2. `has_key(k)`

Comprueba si el diccionario tiene la clave `k`. Es equivalente a la sintaxis `k in D`. Nota: Este m√©todo est√° obsoleto en Python 3 y se debe usar `k in D` en su lugar.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print('b' in mi_dict)  # True
print('d' in mi_dict)  # False
```

### 3. `items()`

Devuelve una vista de los pares clave-valor del diccionario como una lista de tuplas.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print(mi_dict.items())  # dict_items([('a', 1), ('b', 2), ('c', 3)])
```

### 4. `keys()`

Devuelve una vista de las claves del diccionario.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print(mi_dict.keys())  # dict_keys(['a', 'b', 'c'])
```

### 5. `pop(k[, d])`

Borra la clave `k` del diccionario y devuelve su valor. Si no se encuentra dicha clave, se devuelve `d` si se especific√≥ el par√°metro; de lo contrario, se lanza una excepci√≥n `KeyError`.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print(mi_dict.pop('b'))  # 2
print(mi_dict)  # {'a': 1, 'c': 3}
print(mi_dict.pop('d', 'No encontrado'))  # 'No encontrado'
```

### 6. `values()`

Devuelve una vista de los valores del diccionario.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
print(mi_dict.values())  # dict_values([1, 2, 3])
```

## Ejemplos aplicativos

### Contador de Palabras usando Diccionarios

Vamos a crear una funci√≥n que cuente la frecuencia de cada palabra en un texto, utilizando un diccionario para almacenar los resultados.

```python
def contador_palabras(texto):
    palabras = texto.lower().split()
    conteo = {}
    for palabra in palabras:
        if palabra in conteo:
            conteo[palabra] += 1
        else:
            conteo[palabra] = 1
    return conteo

texto = "Hola hola hola Mundo mundo"
print(contador_palabras(texto))
# {'hola': 3, 'mundo': 2}
```

### Combinando M√©todos de Diccionarios y Listas

Podemos usar diccionarios y listas juntos para realizar operaciones m√°s complejas, como agrupar elementos.

#### Agrupando Elementos por Categor√≠a

Supongamos que tenemos una lista de productos y queremos agruparlos por categor√≠a.

```python
productos = [
    ('manzana', 'fruta'),
    ('lechuga', 'vegetal'),
    ('pollo', 'carne'),
    ('pera', 'fruta'),
    ('zanahoria', 'vegetal')
]

agrupados = {}
for producto, categoria in productos:
    if categoria in agrupados:
        agrupados[categoria].append(producto)
    else:
        agrupados[categoria] = [producto]

print(agrupados)
# {'fruta': ['manzana', 'pera'], 'vegetal': ['lechuga', 'zanahoria'], 'carne': ['pollo']}
```

### Invirtiendo un Diccionario

Otra aplicaci√≥n interesante es invertir un diccionario, intercambiando claves y valores.

```python
mi_dict = {'a': 1, 'b': 2, 'c': 3}
invertido = {v: k for k, v in mi_dict.items()}
print(invertido)  # {1: 'a', 2: 'b', 3: 'c'}
```




---



## ¬øQu√© son los Pandas?<a name="pandas"></a>

En el mundo de Python, pandas no se refiere a esos adorables osos, sino a una biblioteca de c√≥digo abierta dise√±ada para ayudarte a trabajar con datos de manera eficiente. Con pandas, puedes cargar, explorar, limpiar y analizar datos en forma de tablas llamadas **DataFrames**. 

Pandas es como un cuchillo suizo para la manipulaci√≥n de datos en Python. Abre un archivo de datos, examina su contenido, realiza c√°lculos y crea gr√°ficos, ¬°todo en un solo lugar!

## ¬øC√≥mo instalar Pandas?

Para importar la librer√≠a Pandas en tus proyectos Python, es imprescindible que te asegures de que la tienes instalada. Para ello, sigue los siguientes pasos con los comandos correspondientes.


| **PASO** | **DESCRIPCI√ìN** | **COMANDO** |
|----------|----------------|-------------|
| 0        | (Opcional) Solo es para asegurar la instalaci√≥n de Python y, de paso, conocer la versi√≥n instalada. Si est√°s seguro de tener Python, no es necesario este paso. | `py --version` |
| 1        | PIP es el manejador de paquetes m√°s popular para Python. En este paso te aseguras de tenerlo instalado y conoces la versi√≥n instalada. | `py -m pip --version` |
| 2        | (Opcional) Actualiza la versi√≥n de PIP por si acaso. | `py -m pip install --upgrade pip` |
| 3        | Usa PIP para instalar NumPy, la librer√≠a en la que se basa Pandas para las estructuras de datos. | `py -m pip install numpy` |
| 4        | Instala Pandas con PIP. Bien podr√≠as ejecutar este comando desde el inicio, pero m√°s vale asegurarte de tener los dem√°s paquetes instalados para no encontrarte con alg√∫n error. | `py -m pip install pandas` |
| 5        | (Opcional) Instala Matplotlib, una librer√≠a que usa Pandas en la funci√≥n plot() para crear gr√°ficas a partir de los datos que se est√°n tratando. | `py -m pip install matplotlib` |




### Inicializando Pandas

Antes de que puedas utilizar a tus compa√±eros pandas, primero debes invocarlos. Importar pandas es tan f√°cil como recitar un hechizo:

```python
import pandas as pd
```

La convenci√≥n de renombrar a pandas como **pd** es una tradici√≥n que facilita su uso.


### ¬øQu√© Son los DataFrames?

En el misterioso reino de Python, un DataFrame es una estructura de datos que se asemeja a una tabla, como las que encuentras en una hoja de c√°lculo. Los DataFrames son el dominio de una poderosa biblioteca llamada **pandas**, dise√±ada para facilitar la manipulaci√≥n y el an√°lisis de datos en Python.

Los DataFrames son como mapas del tesoro que contienen datos organizados en filas y columnas. Cada fila representa una entrada √∫nica, mientras que las columnas representan diferentes caracter√≠sticas o atributos de esas entradas.


### Creando y Explorando DataFrames

Imagina que tienes un conjunto de datos que quieres explorar. Con pandas, puedes crear un DataFrame y cargar tus datos en √©l:

```python
import pandas as pd

# Crear un DataFrame
df = pd.DataFrame({
    'Nombres': ['Harry', 'Hermione', 'Ron', 'Ginny'],
    'Edades': [23, 22, 24, 21],
    'Casas': ['Gryffindor', 'Gryffindor', 'Gryffindor', 'Gryffindor']
})

# Mostrar el DataFrame
print(df)
```

Este c√≥digo crear√° un DataFrame con informaci√≥n sobre algunos de nuestros personajes favoritos de Hogwarts. El DataFrame es como una tabla m√°gica que muestra tus datos en filas y columnas.

### Manipulaci√≥n de Datos

Pandas te permite realizar una variedad de operaciones en tus datos. Por ejemplo, puedes seleccionar filas y columnas, filtrar datos, realizar c√°lculos y mucho m√°s.

```python
# Seleccionar una columna
nombres = df['Nombres']

# Filtrar datos
gryffindor = df[df['Casas'] == 'Gryffindor']

# Calcular estad√≠sticas
promedio_edad = df['Edades'].mean()
```

Puedes ver c√≥mo pandas te brinda un arsenal completo de herramientas para explorar y analizar datos de manera efectiva.

### Visualizaci√≥n de Datos

Pandas tambi√©n se lleva bien con bibliotecas de visualizaci√≥n como **Matplotlib**. Puedes crear gr√°ficos impresionantes para representar tus datos:

```python
import matplotlib.pyplot as plt

# Crear un gr√°fico de barras de edades
plt.bar(df['Nombres'], df['Edades'])
plt.xlabel('Nombres')
plt.ylabel('Edades')
plt.title('Edades de Estudiantes de Gryffindor')
plt.show()
```

¬°Y eso es solo el comienzo! Con pandas, puedes realizar operaciones m√°s avanzadas como agrupaci√≥n, uni√≥n de DataFrames, limpieza de datos y manipulaci√≥n compleja de datos.



### ¬øPor Qu√© Son Importantes los DataFrames?

Los DataFrames son esenciales para tareas de an√°lisis de datos, desde la ciencia de datos hasta la ingenier√≠a financiera y m√°s. Son una herramienta poderosa para organizar, filtrar, resumir y visualizar datos de manera efectiva.

A medida que te aventures m√°s en el mundo de Python, descubrir√°s innumerables aplicaciones para los DataFrames, desde la toma de decisiones basada en datos hasta la generaci√≥n de informes y an√°lisis estad√≠sticos.



Pandas es tu aliado perfecto para el an√°lisis de datos en Python. A medida que avanzas en tu viaje de programaci√≥n, descubrir√°s innumerables aplicaciones para pandas, desde la ciencia de datos hasta el an√°lisis financiero y m√°s.

**¬øQu√© son las Bases de Datos?**

Imagina que eres el bibliotecario de una gran biblioteca. Tienes miles de libros, y cada uno tiene su propio lugar. Organizas estos libros en estantes, y cuando alguien busca un libro en particular, puedes encontrarlo r√°pidamente gracias a la organizaci√≥n. Las bases de datos son como esos estantes y carpetas virtuales para guardar informaci√≥n de manera ordenada.

SQLite es una peque√±a pero potente biblioteca que te permite crear, gestionar y acceder a bases de datos en tus programas de Python. ¬°Vamos a explorar c√≥mo funciona de una manera divertida!

**Creando una Base de Datos con SQLite:**

En el mundo de la programaci√≥n, una base de datos es como un caj√≥n secreto lleno de informaci√≥n √∫til. Para empezar, primero necesitamos crear ese caj√≥n. En SQLite, puedes hacerlo con solo unas pocas l√≠neas de c√≥digo:

```python
import sqlite3

# Conect√©monos a una base de datos o cr√©ala si no existe
conn = sqlite3.connect('mi_base_de_datos.db')

# Creamos una "tabla" en la base de datos para almacenar datos
cursor = conn.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS estudiantes (
        id INTEGER PRIMARY KEY,
        nombre TEXT,
        edad INTEGER
    )
''')
```

En el c√≥digo anterior, estamos conect√°ndonos a una base de datos llamada 'mi_base_de_datos.db' y creando una tabla llamada 'estudiantes' con tres columnas: 'id', 'nombre' y 'edad'. La tabla es como una hoja de registro donde podemos guardar informaci√≥n sobre estudiantes.

**A√±adir Datos a la Base de Datos:**

Ahora que tenemos nuestra tabla, es hora de llenarla con informaci√≥n. Imagina que eres un maestro y quieres registrar a tus estudiantes en la base de datos. Podemos hacerlo as√≠:

```python
# Insertamos datos en la tabla
cursor.execute('INSERT INTO estudiantes (nombre, edad) VALUES (?, ?)', ('Juan', 12))
cursor.execute('INSERT INTO estudiantes (nombre, edad) VALUES (?, ?)', ('Maria', 11))

# Guardamos los cambios
conn.commit()
```

Hemos a√±adido dos estudiantes, Juan y Maria, a nuestra tabla. Puedes agregar tantos estudiantes como quieras, y SQLite los mantendr√° organizados en tu base de datos.

**Consultar Datos en la Base de Datos:**

Ahora que hemos guardado datos, ¬øc√≥mo podemos encontrarlos cuando los necesitemos? SQLite nos permite hacer consultas para buscar informaci√≥n espec√≠fica. Imagina que deseas encontrar la edad de Juan:

```python
# Consultamos la base de datos para encontrar la edad de Juan
cursor.execute('SELECT edad FROM estudiantes WHERE nombre = ?', ('Juan',))
edad_juan = cursor.fetchone()[0]
print(f'La edad de Juan es {edad_juan} a√±os.')
```

Con esta consulta, estamos buscando la edad de un estudiante cuyo nombre es 'Juan'. SQLite nos devuelve el resultado y podemos imprimirlo en pantalla.

**Cerrando el Caj√≥n:**

Cuando termines de trabajar con tu base de datos, aseg√∫rate de cerrarla correctamente:

```python
# Cerramos la conexi√≥n a la base de datos
conn.close()
```

Esto es como cerrar un caj√≥n despu√©s de usarlo. ¬°Aseg√∫rate de hacerlo para mantener tus datos seguros y ordenados!